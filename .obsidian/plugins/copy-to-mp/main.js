/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyDocumentAsHTMLPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// styles_temp.js
var STYLES = {
  "wechat-default": {
    name: "\u9ED8\u8BA4\u516C\u4F17\u53F7\u98CE\u683C",
    styles: {
      container: 'max-width: 740px; margin: 0 auto; padding: 20px 12px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; font-size: 16px; line-height: 1.8 !important; color: #3f3f3f !important; background-color: #fff !important; word-wrap: break-word;',
      h1: "font-size: 24px; font-weight: 600; color: #2c3e50 !important; line-height: 1.4 !important; margin: 32px 0 16px; padding-bottom: 8px; border-bottom: 2px solid #3498db;",
      h2: "font-size: 22px; font-weight: 600; color: #2c3e50 !important; line-height: 1.4 !important; margin: 28px 0 14px; padding-left: 12px; border-left: 4px solid #3498db;",
      h3: "font-size: 20px; font-weight: 600; color: #34495e !important; line-height: 1.4 !important; margin: 24px 0 12px;",
      h4: "font-size: 18px; font-weight: 600; color: #34495e !important; line-height: 1.4 !important; margin: 20px 0 10px;",
      h5: "font-size: 17px; font-weight: 600; color: #34495e !important; line-height: 1.4 !important; margin: 18px 0 9px;",
      h6: "font-size: 16px; font-weight: 600; color: #34495e !important; line-height: 1.4 !important; margin: 16px 0 8px;",
      p: "margin: 16px 0 !important; line-height: 1.8 !important; color: #3f3f3f !important;",
      strong: "font-weight: 600; color: #2c3e50 !important;",
      em: "font-style: italic; color: #555 !important;",
      a: "color: #3498db !important; text-decoration: none; border-bottom: 1px solid #3498db;",
      ul: "margin: 16px 0; padding-left: 24px;",
      ol: "margin: 16px 0; padding-left: 24px;",
      li: "margin: 8px 0; line-height: 1.8 !important;",
      blockquote: "margin: 16px 0; padding: 10px 16px; background-color: #fafafa !important; border-left: 3px solid #999; color: #666 !important; line-height: 1.6 !important;",
      code: 'font-family: Consolas, Monaco, "Courier New", monospace; font-size: 14px; padding: 2px 6px; background-color: #f5f5f5 !important; color: #e74c3c !important; border-radius: 3px;',
      pre: "margin: 20px 0; padding: 16px; background-color: #2d2d2d !important; border-radius: 8px; overflow-x: auto; line-height: 1.6 !important;",
      hr: "margin: 32px 0; border: none; border-top: 1px solid #e0e0e0;",
      img: "max-width: 100%; max-height: 600px !important; height: auto; display: block; margin: 20px auto; border-radius: 8px;",
      table: "width: 100%; margin: 20px 0; border-collapse: collapse; font-size: 15px;",
      th: "background-color: #f0f0f0 !important; padding: 10px; text-align: left; border: 1px solid #e0e0e0; font-weight: 600;",
      td: "padding: 10px; border: 1px solid #e0e0e0;",
      tr: "border-bottom: 1px solid #e0e0e0;"
    }
  },
  "latepost-depth": {
    name: "\u665A\u70B9\u98CE\u683C",
    styles: {
      container: 'max-width: 700px; margin: 0 auto; padding: 40px 12px; font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; font-size: 17px; line-height: 1.8 !important; color: #1a1a1a !important; background-color: #fff !important; word-wrap: break-word;',
      h1: "font-size: 32px; font-weight: 700; color: #1a1a1a !important; line-height: 1.3 !important; margin: 48px 0 28px; padding-left: 20px; border-left: 6px solid #d32f2f; position: relative;",
      h2: "font-size: 24px; font-weight: 600; color: #fff !important; line-height: 1.4 !important; margin: 40px 0 24px; padding: 16px 24px; background-color: #d32f2f !important; border-radius: 4px; position: relative;",
      h3: "font-size: 20px; font-weight: 600; color: #d32f2f !important; line-height: 1.5 !important; margin: 35px 0 20px; padding-left: 16px; border-left: 4px solid #d32f2f; position: relative;",
      h4: "font-size: 18px; font-weight: 600; color: #1a1a1a !important; line-height: 1.5 !important; margin: 30px 0 16px; padding: 8px 12px; background-color: #f5f5f5 !important; border-left: 3px solid #ff5252;",
      h5: "font-size: 17px; font-weight: 600; color: #333 !important; line-height: 1.5 !important; margin: 25px 0 14px;",
      h6: "font-size: 16px; font-weight: 500; color: #666 !important; line-height: 1.5 !important; margin: 20px 0 12px;",
      p: "margin: 20px 0 !important; line-height: 1.9 !important; color: #1a1a1a !important;",
      strong: "font-weight: 700; color: #d32f2f !important; background-color: rgba(211, 47, 47, 0.08) !important; padding: 2px 6px; border-radius: 3px;",
      em: "font-style: italic; color: #666 !important;",
      a: "color: #d32f2f !important; text-decoration: none; border-bottom: 1px solid #d32f2f;",
      ul: "margin: 24px 0; padding-left: 28px; list-style-type: disc;",
      ol: "margin: 24px 0; padding-left: 28px; list-style-type: decimal;",
      li: "margin: 12px 0; line-height: 1.8 !important; color: #1a1a1a !important;",
      blockquote: "margin: 32px 0; padding: 20px 24px 20px 20px; background-color: #f5f5f5 !important; border-left: 4px solid #d32f2f; color: #1a1a1a !important; font-size: 16px; line-height: 1.8 !important; position: relative; border-radius: 4px;",
      code: 'font-family: "SF Mono", Menlo, Consolas, monospace; font-size: 15px; padding: 3px 8px; background-color: #f5f5f5 !important; color: #d32f2f !important; border-radius: 4px; font-weight: 500;',
      pre: "margin: 28px 0; padding: 20px; background-color: #2a2a2a !important; color: #f5f5f5 !important; border-radius: 6px; overflow-x: auto; line-height: 1.6 !important; border-left: 4px solid #d32f2f;",
      hr: "margin: 40px auto; border: none; height: 2px; background: linear-gradient(to right, transparent, #d32f2f, transparent); max-width: 200px;",
      img: "max-width: 100%; max-height: 600px !important; height: auto; display: block; margin: 32px auto; border-radius: 6px; border: 2px solid #d32f2f; box-shadow: 0 4px 12px rgba(211, 47, 47, 0.12);",
      table: "width: 100%; margin: 28px 0; border-collapse: collapse; font-size: 16px; border-radius: 6px; overflow: hidden;",
      th: "background-color: #d32f2f !important; color: #fff !important; padding: 12px 16px; text-align: left; font-weight: 600; border: none;",
      td: "padding: 12px 16px; border: none; border-bottom: 1px solid #e0e0e0; color: #1a1a1a !important; background-color: #fff !important;",
      tr: "border-bottom: 1px solid #e0e0e0;"
    }
  }
};

// main.ts
function allWithProgress(promises, callback) {
  let count = 0;
  callback(0);
  for (const promise of promises) {
    promise.then(() => {
      count++;
      callback(count * 100 / promises.length);
    }).catch(() => {
      count++;
      callback(count * 100 / promises.length);
    });
  }
  return Promise.all(promises);
}
async function delay(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
var DEFAULT_STYLESHEET = `body,input {
  font-family: "Roboto","Helvetica Neue",Helvetica,Arial,sans-serif
}

code, kbd, pre {
  font-family: "Roboto Mono", "Courier New", Courier, monospace;
  background-color: #f5f5f5;
}

pre {
  padding: 1em 0.5em;
}

table {
  background: white;
  border: 1px solid #666;
  border-collapse: collapse;
  padding: 0.5em;
}

table thead th,
table tfoot th {
  text-align: left;
  background-color: #eaeaea;
  color: black;
}

table th, table td {
  border: 1px solid #ddd;
  padding: 0.5em;
}

table td {
  color: #222222;
}

.callout[data-callout="abstract"] .callout-title,
.callout[data-callout="summary"] .callout-title,
.callout[data-callout="tldr"]  .callout-title,
.callout[data-callout="faq"] .callout-title,
.callout[data-callout="info"] .callout-title,
.callout[data-callout="help"] .callout-title {
  background-color: #828ee7;
}
.callout[data-callout="tip"] .callout-title,
.callout[data-callout="hint"] .callout-title,
.callout[data-callout="important"] .callout-title {
  background-color: #34bbe6;
}
.callout[data-callout="success"] .callout-title,
.callout[data-callout="check"] .callout-title,
.callout[data-callout="done"] .callout-title {
  background-color: #a3e048;
}
.callout[data-callout="question"] .callout-title,
.callout[data-callout="todo"] .callout-title {
  background-color: #49da9a;
}
.callout[data-callout="caution"] .callout-title,
.callout[data-callout="attention"] .callout-title {
  background-color: #f7d038;
}
.callout[data-callout="warning"] .callout-title,
.callout[data-callout="missing"] .callout-title,
.callout[data-callout="bug"] .callout-title {
  background-color: #eb7532;
}
.callout[data-callout="failure"] .callout-title,
.callout[data-callout="fail"] .callout-title,
.callout[data-callout="danger"] .callout-title,
.callout[data-callout="error"] .callout-title {
  background-color: #e6261f;
}
.callout[data-callout="example"] .callout-title {
  background-color: #d23be7;
}
.callout[data-callout="quote"] .callout-title,
.callout[data-callout="cite"] .callout-title {
  background-color: #aaaaaa;
}

.callout-icon {
  flex: 0 0 auto;
  display: flex;
  align-self: center;
}

svg.svg-icon {
  height: 18px;
  width: 18px;
  stroke-width: 1.75px;
}

.callout {
  overflow: hidden;
  margin: 1em 0;
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

.callout-title {
  padding: .5em;
  display: flex;
  gap: 8px;
  font-size: inherit;
  color: black;
  line-height: 1.3em;
}

.callout-title-inner {
  font-weight: bold;
  color: black;
}

.callout-content {
  overflow-x: auto;
  padding: 0.25em .5em;
  color: #222222;
  background-color: white !important;
}

ul.contains-task-list {
  padding-left: 0;
  list-style: none;
}

ul.contains-task-list ul.contains-task-list {
  padding-left: 2em;
}

ul.contains-task-list li input[type="checkbox"] {
  margin-right: .5em;
}

.callout-table,
.callout-table tr,
.callout-table p {
  width: 100%;
  padding: 0;
}

.callout-table td {
  width: 100%;
  padding: 0 1em;
}

.callout-table p {
  padding-bottom: 0.5em;
}

.source-table {
  width: 100%;
  background-color: #f5f5f5;
}
`;
var MERMAID_STYLESHEET = `
:root {
  --default-font: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
  --font-monospace: 'Source Code Pro', monospace;
  --background-primary: #ffffff;
  --background-modifier-border: #ddd;
  --text-accent: #705dcf;
  --text-accent-hover: #7a6ae6;
  --text-normal: #2e3338;
  --background-secondary: #f2f3f5;
  --background-secondary-alt: #fcfcfc;
  --text-muted: #888888;
  --font-mermaid: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Microsoft YaHei Light", sans-serif;
  --text-error: #E4374B;
  --background-primary-alt: '#fafafa';
  --background-accent: '';
  --interactive-accent: hsl( 254,  80%, calc( 68% + 2.5%));
  --background-modifier-error: #E4374B;
  --background-primary-alt: #fafafa;
  --background-modifier-border: #e0e0e0;
}
`;
var DEFAULT_HTML_TEMPLATE = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>\${title}</title>
  <style>
    \${MERMAID_STYLESHEET}
    \${stylesheet}
  </style>
</head>
<body>
\${body}
</body>
</html>
`;
var copyIsRunning = false;
var ppIsProcessing = false;
var ppLastBlockDate = Date.now();
var documentRendererDefaults = {
  convertSvgToBitmap: true,
  removeFrontMatter: true,
  formatCodeWithTables: false,
  embedExternalLinks: false,
  removeDataviewMetadataLines: false,
  footnoteHandling: 2 /* REMOVE_LINK */,
  internalLinkHandling: 0 /* CONVERT_TO_TEXT */,
  disableImageEmbedding: false
};
var DocumentRenderer = class {
  constructor(app, options = documentRendererDefaults) {
    this.app = app;
    this.options = options;
    this.optionRenderSettlingDelay = 100;
    this.mimeMap = /* @__PURE__ */ new Map([
      ["svg", "image/svg+xml"],
      ["jpg", "image/jpeg"]
    ]);
    this.externalSchemes = ["http", "https"];
    this.vaultPath = this.app.vault.getRoot().vault.adapter.getBasePath().replace(/\\/g, "/");
    this.vaultLocalUriPrefix = `app://local/${this.vaultPath}`;
    this.vaultOpenUri = `obsidian://open?vault=${encodeURIComponent(this.app.vault.getName())}`;
    this.vaultSearchUri = `obsidian://search?vault=${encodeURIComponent(this.app.vault.getName())}`;
    this.view = new import_obsidian.Component();
  }
  async renderDocument(markdown, path) {
    this.modal = new CopyingToHtmlModal(this.app);
    this.modal.open();
    try {
      const topNode = await this.renderMarkdown(markdown, path);
      return await this.transformHTML(topNode);
    } finally {
      this.modal.close();
    }
  }
  async renderMarkdown(markdown, path) {
    const processedMarkdown = this.preprocessMarkdown(markdown);
    const wrapper = document.createElement("div");
    wrapper.addClass("hidden");
    document.body.appendChild(wrapper);
    await import_obsidian.MarkdownRenderer.render(this.app, processedMarkdown, wrapper, path, this.view);
    await this.untilRendered();
    await this.loadComponents(this.view);
    const result = wrapper.cloneNode(true);
    document.body.removeChild(wrapper);
    this.view.unload();
    return result;
  }
  async loadComponents(view) {
    const internalView = view;
    const loadChildren = async (component, visited = /* @__PURE__ */ new Set()) => {
      var _a, _b;
      if (visited.has(component)) {
        return;
      }
      visited.add(component);
      const internalComponent = component;
      if ((_a = internalComponent._children) == null ? void 0 : _a.length) {
        for (const child of internalComponent._children) {
          await loadChildren(child, visited);
        }
      }
      try {
        if (((_b = component == null ? void 0 : component.constructor) == null ? void 0 : _b.name) === "SheetElement") {
          component.onload();
        }
      } catch (error) {
        console.error(`Error calling onload()`, error);
      }
    };
    await loadChildren(internalView);
  }
  preprocessMarkdown(markdown) {
    let processed = markdown;
    if (this.options.removeDataviewMetadataLines) {
      processed = processed.replace(/^[^ \t:#`<>][^:#`<>]+::.*$/gm, "");
    }
    return processed;
  }
  async untilRendered() {
    while (ppIsProcessing || Date.now() - ppLastBlockDate < this.optionRenderSettlingDelay) {
      if (ppLastBlockDate === 0) {
        break;
      }
      await delay(20);
    }
  }
  async transformHTML(element) {
    const node = element.cloneNode(true);
    node.removeAttribute("style");
    if (this.options.removeFrontMatter) {
      this.removeFrontMatter(node);
    }
    this.replaceLinksOfClass(node, "internal-link");
    this.replaceLinksOfClass(node, "tag");
    this.makeCheckboxesReadOnly(node);
    this.removeCollapseIndicators(node);
    this.removeButtons(node);
    this.removeStrangeNewWorldsLinks(node);
    if (this.options.footnoteHandling == 0 /* REMOVE_ALL */) {
      this.removeAllFootnotes(node);
    }
    if (this.options.footnoteHandling == 2 /* REMOVE_LINK */) {
      this.removeFootnoteLinks(node);
    } else if (this.options.footnoteHandling == 3 /* TITLE_ATTRIBUTE */) {
    }
    if (!this.options.disableImageEmbedding) {
      await this.embedImages(node);
      await this.renderSvg(node);
    }
    return node;
  }
  removeFrontMatter(node) {
    node.querySelectorAll(".frontmatter, .frontmatter-container").forEach((node2) => node2.remove());
  }
  replaceLinksOfClass(node, className) {
    if (this.options.internalLinkHandling === 3 /* LEAVE_AS_IS */) {
      return;
    }
    node.querySelectorAll(`a.${className}`).forEach((node2) => {
      switch (this.options.internalLinkHandling) {
        case 1 /* CONVERT_TO_OBSIDIAN_URI */:
          {
            const linkNode = node2.parentNode.createEl("a");
            linkNode.innerText = node2.getText();
            if (className === "tag") {
              linkNode.href = this.vaultSearchUri + "&query=tag:" + encodeURIComponent(node2.getAttribute("href"));
            } else {
              if (node2.getAttribute("href").startsWith("#")) {
                linkNode.href = node2.getAttribute("href");
              } else {
                linkNode.href = this.vaultOpenUri + "&file=" + encodeURIComponent(node2.getAttribute("href"));
              }
            }
            linkNode.className = className;
            node2.parentNode.replaceChild(linkNode, node2);
          }
          break;
        case 2 /* LINK_TO_HTML */:
          {
            const linkNode = node2.parentNode.createEl("a");
            linkNode.innerText = node2.getAttribute("href");
            linkNode.className = className;
            if (node2.getAttribute("href").startsWith("#")) {
              linkNode.href = node2.getAttribute("href");
            } else {
              linkNode.href = node2.getAttribute("href").replace(/^(.*?)(?:\.md)?(#.*?)?$/, "$1.html$2");
            }
            node2.parentNode.replaceChild(linkNode, node2);
          }
          break;
        case 0 /* CONVERT_TO_TEXT */:
        default:
          {
            const textNode = node2.parentNode.createEl("span");
            textNode.innerText = node2.getText();
            textNode.className = className;
            node2.parentNode.replaceChild(textNode, node2);
          }
          break;
      }
    });
  }
  makeCheckboxesReadOnly(node) {
    node.querySelectorAll('input[type="checkbox"]').forEach((node2) => node2.setAttribute("disabled", "disabled"));
  }
  removeCollapseIndicators(node) {
    node.querySelectorAll(".collapse-indicator").forEach((node2) => node2.remove());
  }
  removeButtons(node) {
    node.querySelectorAll("button").forEach((node2) => node2.remove());
  }
  removeStrangeNewWorldsLinks(node) {
    node.querySelectorAll(".snw-reference").forEach((node2) => node2.remove());
  }
  removeAllFootnotes(node) {
    node.querySelectorAll("section.footnotes").forEach((section) => section.parentNode.removeChild(section));
    node.querySelectorAll(".footnote-link").forEach((link) => {
      link.parentNode.parentNode.removeChild(link.parentNode);
    });
  }
  removeFootnoteLinks(node) {
    node.querySelectorAll(".footnote-link").forEach((link) => {
      const text = link.getText();
      if (text === "\u21A9\uFE0E") {
        link.parentNode.removeChild(link);
      } else {
        const span = link.parentNode.createEl("span", { text: link.getText(), cls: "footnote-link" });
        link.parentNode.replaceChild(span, link);
      }
    });
  }
  async embedImages(node) {
    const promises = [];
    node.querySelectorAll("img").forEach((img) => {
      if (img.src) {
        if (img.src.startsWith("data:image/svg+xml") && this.options.convertSvgToBitmap) {
          promises.push(this.replaceImageSource(img));
          return;
        }
        if (!this.options.embedExternalLinks) {
          const [scheme] = img.src.split(":", 1);
          if (this.externalSchemes.includes(scheme.toLowerCase())) {
            return;
          } else {
          }
        }
        if (!img.src.startsWith("data:")) {
          promises.push(this.replaceImageSource(img));
          return;
        }
      }
    });
    this.modal.progress.max = 100;
    await allWithProgress(promises, (percentCompleted) => this.modal.progress.value = percentCompleted);
    return node;
  }
  async renderSvg(node) {
    const xmlSerializer = new XMLSerializer();
    if (!this.options.convertSvgToBitmap) {
      return node;
    }
    const promises = [];
    const replaceSvg = async (svg) => {
      const style = svg.querySelector("style") || svg.appendChild(document.createElement("style"));
      const textNode = document.createTextNode(MERMAID_STYLESHEET);
      style.appendChild(textNode);
      const svgAsString = xmlSerializer.serializeToString(svg);
      const svgData = `data:image/svg+xml;base64,` + Buffer.from(svgAsString).toString("base64");
      const dataUri = await this.imageToDataUri(svgData);
      const img = svg.createEl("img");
      img.style.cssText = svg.style.cssText;
      img.src = dataUri;
      svg.parentElement.replaceChild(img, svg);
    };
    node.querySelectorAll("svg").forEach((svg) => {
      promises.push(replaceSvg(svg));
    });
    this.modal.progress.max = 0;
    await allWithProgress(promises, (percentCompleted) => this.modal.progress.value = percentCompleted);
    return node;
  }
  async replaceImageSource(image) {
    const imageSourcePath = decodeURI(image.src);
    if (imageSourcePath.startsWith(this.vaultLocalUriPrefix)) {
      let path = imageSourcePath.substring(this.vaultLocalUriPrefix.length + 1).replace(/[?#].*/, "");
      path = decodeURI(path);
      const mimeType = this.guessMimeType(path);
      const data = await this.readFromVault(path, mimeType);
      if (this.isSvg(mimeType) && this.options.convertSvgToBitmap) {
        image.src = await this.imageToDataUri(data);
      } else {
        image.src = data;
      }
    } else {
      image.src = await this.imageToDataUri(image.src);
    }
  }
  async imageToDataUri(url) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const image = new Image();
    image.setAttribute("crossOrigin", "anonymous");
    const dataUriPromise = new Promise((resolve, reject) => {
      image.onload = () => {
        canvas.width = image.naturalWidth;
        canvas.height = image.naturalHeight;
        ctx.drawImage(image, 0, 0);
        try {
          const uri = canvas.toDataURL("image/png");
          resolve(uri);
        } catch (err) {
          console.error(`failed ${url}`, err);
          resolve(url);
        }
        canvas.remove();
      };
      image.onerror = (err) => {
        console.error("could not load data uri");
        resolve(url);
      };
    });
    image.src = url;
    return dataUriPromise;
  }
  async readFromVault(path, mimeType) {
    const tfile = this.app.vault.getAbstractFileByPath(path);
    const data = await this.app.vault.readBinary(tfile);
    return `data:${mimeType};base64,` + (0, import_obsidian.arrayBufferToBase64)(data);
  }
  guessMimeType(filePath) {
    const extension = this.getExtension(filePath) || "png";
    return this.mimeMap.get(extension) || `image/${extension}`;
  }
  getExtension(filePath) {
    const fileName = filePath.slice(filePath.lastIndexOf("/") + 1);
    return fileName.slice(fileName.lastIndexOf(".") + 1 || fileName.length).toLowerCase();
  }
  isSvg(mimeType) {
    return mimeType === "image/svg+xml";
  }
};
var CopyingToHtmlModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  get progress() {
    return this._progress;
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText("Copying to clipboard");
    this._progress = contentEl.createEl("progress");
    this._progress.style.width = "100%";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var _CopyDocumentAsHTMLSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u8BBE\u7F6E" });
    containerEl.createEl("h3", { text: "\u517C\u5BB9\u6027\u9009\u9879" });
    new import_obsidian.Setting(containerEl).setName("\u5C06 SVG \u8F6C\u6362\u4E3A\u4F4D\u56FE").setDesc("\u5982\u679C\u9009\u4E2D\uFF0CSVG \u6587\u4EF6\u5C06\u8F6C\u6362\u4E3A\u4F4D\u56FE\u3002\u8FD9\u4F1A\u4F7F\u590D\u5236\u7684\u6587\u6863 heavier \u4F46\u63D0\u9AD8\u517C\u5BB9\u6027\uFF08\u4F8B\u5982 Gmail\uFF09\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.convertSvgToBitmap).onChange(async (value) => {
      this.plugin.settings.convertSvgToBitmap = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u5D4C\u5165\u5916\u90E8\u56FE\u7247").setDesc("\u5982\u679C\u9009\u4E2D\uFF0C\u5916\u90E8\u56FE\u7247\u5C06\u88AB\u4E0B\u8F7D\u5E76\u5D4C\u5165\u3002\u5982\u679C\u53D6\u6D88\u9009\u4E2D\uFF0C\u751F\u6210\u7684\u6587\u6863\u53EF\u80FD\u5305\u542B\u6307\u5411\u5916\u90E8\u8D44\u6E90\u7684\u94FE\u63A5").addToggle((toggle) => toggle.setValue(this.plugin.settings.embedExternalLinks).onChange(async (value) => {
      this.plugin.settings.embedExternalLinks = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "\u6E32\u67D3\u9009\u9879" });
    new import_obsidian.Setting(containerEl).setName("\u5305\u542B\u6587\u4EF6\u540D\u4F5C\u4E3A\u6807\u9898").setDesc("\u5982\u679C\u9009\u4E2D\uFF0C\u6587\u4EF6\u540D\u5C06\u4F5C\u4E3A\u4E00\u7EA7\u6807\u9898\u63D2\u5165\u3002\uFF08\u4EC5\u5F53\u6574\u4E2A\u6587\u6863\u88AB\u590D\u5236\u65F6\u624D\u6709\u6548\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.fileNameAsHeader).onChange(async (value) => {
      this.plugin.settings.fileNameAsHeader = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u79FB\u9664\u5C5E\u6027/\u524D\u7F6E\u5143\u6570\u636E\u90E8\u5206").setDesc("\u5982\u679C\u9009\u4E2D\uFF0C\u5C06\u79FB\u9664\u6587\u6863\u5F00\u5934\u4F4D\u4E8E --- \u884C\u4E4B\u95F4\u7684 YAML \u5185\u5BB9\u3002\u5982\u679C\u60A8\u4E0D\u77E5\u9053\u8FD9\u662F\u4EC0\u4E48\uFF0C\u8BF7\u4FDD\u6301\u5F00\u542F\u72B6\u6001\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.removeFrontMatter).onChange(async (value) => {
      this.plugin.settings.removeFrontMatter = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u79FB\u9664\u6570\u636E\u89C6\u56FE\u5143\u6570\u636E\u884C").setDesc(_CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`
				<p>\u5982\u679C\u9009\u4E2D\uFF0C\u5C06\u79FB\u9664\u4EC5\u5305\u542B\u6570\u636E\u89C6\u56FE\u5143\u6570\u636E\u7684\u884C\uFF0C\u4F8B\u5982 "rating:: 9"\u3002\u65B9\u62EC\u53F7\u4E2D\u7684\u5143\u6570\u636E\u5C06\u4FDD\u6301\u4E0D\u53D8\u3002</p>
				<p>\u5F53\u524D\u9650\u5236\u662F\uFF0C\u4EE5\u7A7A\u683C\u5F00\u5934\u7684\u884C\u4E0D\u4F1A\u88AB\u79FB\u9664\uFF0C\u800C\u4EE3\u7801\u5757\u4E2D\u7684\u5143\u6570\u636E\u884C\u5982\u679C\u4E0D\u4EE5\u7A7A\u683C\u5F00\u5934\uFF0C\u4E5F\u4F1A\u88AB\u79FB\u9664\u3002</p>`)).addToggle((toggle) => toggle.setValue(this.plugin.settings.removeDataviewMetadataLines).onChange(async (value) => {
      this.plugin.settings.removeDataviewMetadataLines = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u811A\u6CE8\u5904\u7406").setDesc(_CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`
				<ul>
				  <li>\u5168\u90E8\u79FB\u9664\uFF1A\u79FB\u9664\u5F15\u7528\u548C\u94FE\u63A5\u3002</li>
				  <li>\u4EC5\u663E\u793A\uFF1A\u4FDD\u7559\u5F15\u7528\u548C\u811A\u6CE8\uFF0C\u4F46\u4E0D\u663E\u793A\u4E3A\u94FE\u63A5\u3002</li>
				  <li>\u663E\u793A\u5E76\u94FE\u63A5\uFF1A\u5C1D\u8BD5\u5C06\u5F15\u7528\u94FE\u63A5\u5230\u811A\u6CE8\uFF0C\u6839\u636E\u7C98\u8D34\u76EE\u6807\u7684\u4E0D\u540C\u53EF\u80FD\u4E0D\u8D77\u4F5C\u7528\u3002</li>
				</ul>`)).addDropdown((dropdown) => dropdown.addOption(0 /* REMOVE_ALL */.toString(), "\u5168\u90E8\u79FB\u9664").addOption(2 /* REMOVE_LINK */.toString(), "\u4EC5\u663E\u793A").addOption(1 /* LEAVE_LINK */.toString(), "\u663E\u793A\u5E76\u94FE\u63A5").setValue(this.plugin.settings.footnoteHandling.toString()).onChange(async (value) => {
      switch (value) {
        case 3 /* TITLE_ATTRIBUTE */.toString():
          this.plugin.settings.footnoteHandling = 3 /* TITLE_ATTRIBUTE */;
          break;
        case 0 /* REMOVE_ALL */.toString():
          this.plugin.settings.footnoteHandling = 0 /* REMOVE_ALL */;
          break;
        case 2 /* REMOVE_LINK */.toString():
          this.plugin.settings.footnoteHandling = 2 /* REMOVE_LINK */;
          break;
        case 1 /* LEAVE_LINK */.toString():
        default:
          this.plugin.settings.footnoteHandling = 1 /* LEAVE_LINK */;
          break;
      }
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u5185\u90E8\u94FE\u63A5\u5904\u7406").setDesc(_CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`
				<p>\u6B64\u9009\u9879\u63A7\u5236\u5BF9 Obsidian \u6587\u6863\u548C\u6807\u7B7E\u7684\u94FE\u63A5\u7684\u5904\u7406\u65B9\u5F0F\u3002</p>
				<ul>
				  <li>Don't link: only render the link title</li>
				  <li>Open with Obsidian: convert the link to an obsidian:// URI</li> 
				  <li>Link to HTML: keep the link, but convert the extension to .html</li>
				  <li>Leave as is: keep the generated link</li>	
				</ul>`)).addDropdown((dropdown) => dropdown.addOption(0 /* CONVERT_TO_TEXT */.toString(), "Don't link").addOption(1 /* CONVERT_TO_OBSIDIAN_URI */.toString(), "Open with Obsidian").addOption(2 /* LINK_TO_HTML */.toString(), "Link to HTML").addOption(3 /* LEAVE_AS_IS */.toString(), "Leave as is").setValue(this.plugin.settings.internalLinkHandling.toString()).onChange(async (value) => {
      switch (value) {
        case 1 /* CONVERT_TO_OBSIDIAN_URI */.toString():
          this.plugin.settings.internalLinkHandling = 1 /* CONVERT_TO_OBSIDIAN_URI */;
          break;
        case 2 /* LINK_TO_HTML */.toString():
          this.plugin.settings.internalLinkHandling = 2 /* LINK_TO_HTML */;
          break;
        case 3 /* LEAVE_AS_IS */.toString():
          this.plugin.settings.internalLinkHandling = 3 /* LEAVE_AS_IS */;
          break;
        case 0 /* CONVERT_TO_TEXT */.toString():
        default:
          this.plugin.settings.internalLinkHandling = 0 /* CONVERT_TO_TEXT */;
          break;
      }
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "\u81EA\u5B9A\u4E49\u6A21\u677F\uFF08\u9AD8\u7EA7\uFF09" });
    const useCustomStylesheetSetting = new import_obsidian.Setting(containerEl).setName("\u4F7F\u7528\u81EA\u5B9A\u4E49\u6837\u5F0F\u8868\uFF08\u5F85\u5B9E\u73B0\uFF09").setDesc("\u9ED8\u8BA4\u6837\u5F0F\u8868\u63D0\u4F9B\u4E86\u57FA\u672C\u7684\u4E3B\u9898\u3002\u60A8\u53EF\u80FD\u9700\u8981\u81EA\u5B9A\u4E49\u5B83\u4EE5\u83B7\u5F97\u66F4\u597D\u7684\u5916\u89C2\u3002\u7981\u7528\u6B64\u8BBE\u7F6E\u5C06\u6062\u590D\u9ED8\u8BA4\u6837\u5F0F\u8868\u3002");
    const customStylesheetSetting = new import_obsidian.Setting(containerEl).setClass("customizable-text-setting").addTextArea((textArea) => textArea.setValue(this.plugin.settings.styleSheet).onChange(async (value) => {
      this.plugin.settings.styleSheet = value;
      await this.plugin.saveSettings();
    }));
    useCustomStylesheetSetting.addToggle((toggle) => {
      customStylesheetSetting.settingEl.toggle(this.plugin.settings.useCustomStylesheet);
      toggle.setValue(this.plugin.settings.useCustomStylesheet).onChange(async (value) => {
        this.plugin.settings.useCustomStylesheet = value;
        customStylesheetSetting.settingEl.toggle(this.plugin.settings.useCustomStylesheet);
        if (!value) {
          this.plugin.settings.styleSheet = DEFAULT_STYLESHEET;
        }
        await this.plugin.saveSettings();
      });
    });
    const useCustomHtmlTemplateSetting = new import_obsidian.Setting(containerEl).setName("\u4F7F\u7528\u81EA\u5B9A\u4E49 HTML \u6A21\u677F\uFF08\u5F85\u5B9E\u73B0\uFF09").setDesc(_CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`For even more customization, you can 
provide a custom HTML template. Disabling this setting will restore the default template.<br/><br/>
Note that the template is not used if the "Copy HTML fragment only" setting is enabled.`));
    const customHtmlTemplateSetting = new import_obsidian.Setting(containerEl).setDesc(_CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML(`
			The template should include the following placeholders :<br/>
<ul>
	<li><code>\${title}</code>: the document title</li>
	<li><code>\${stylesheet}</code>: the CSS stylesheet. The custom stylesheet will be applied if any is specified</li>
	<li><code>\${MERMAID_STYLESHEET}</code>: the CSS for mermaid diagrams</li>
	<li><code>\${body}</code>: the document body</li>
</ul>`)).setClass("customizable-text-setting").addTextArea((textArea) => textArea.setValue(this.plugin.settings.htmlTemplate).onChange(async (value) => {
      this.plugin.settings.htmlTemplate = value;
      await this.plugin.saveSettings();
    }));
    useCustomHtmlTemplateSetting.addToggle((toggle) => {
      customHtmlTemplateSetting.settingEl.toggle(this.plugin.settings.useCustomHtmlTemplate);
      toggle.setValue(this.plugin.settings.useCustomHtmlTemplate).onChange(async (value) => {
        this.plugin.settings.useCustomHtmlTemplate = value;
        customHtmlTemplateSetting.settingEl.toggle(this.plugin.settings.useCustomHtmlTemplate);
        if (!value) {
          this.plugin.settings.htmlTemplate = DEFAULT_HTML_TEMPLATE;
        }
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "\u5176\u4ED6 / \u5F00\u53D1\u9009\u9879" });
    new import_obsidian.Setting(containerEl).setName("\u7981\u7528\u56FE\u7247\u5D4C\u5165").setDesc("\u542F\u7528\u6B64\u9009\u9879\u540E\uFF0C\u56FE\u7247\u5C06\u4E0D\u4F1A\u5D4C\u5165 HTML \u6587\u6863\u4E2D\uFF0C\u800C\u662F\u4FDD\u7559\u4E3A <em>\u635F\u574F\u7684\u94FE\u63A5</em>\u3002\u8FD9\u4E0D\u662F\u63A8\u8350\u7684\u505A\u6CD5\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.disableImageEmbedding).onChange(async (value) => {
      this.plugin.settings.disableImageEmbedding = value;
      await this.plugin.saveSettings();
    }));
  }
};
var CopyDocumentAsHTMLSettingsTab = _CopyDocumentAsHTMLSettingsTab;
CopyDocumentAsHTMLSettingsTab.createFragmentWithHTML = (html) => {
  return createFragment((documentFragment) => {
    const div = documentFragment.createDiv();
    div.empty();
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = html;
    while (tempDiv.firstChild) {
      div.appendChild(tempDiv.firstChild);
    }
  });
};
var DEFAULT_SETTINGS = {
  removeFrontMatter: true,
  convertSvgToBitmap: true,
  useCustomStylesheet: false,
  useCustomHtmlTemplate: false,
  embedExternalLinks: false,
  removeDataviewMetadataLines: false,
  formatCodeWithTables: false,
  formatCalloutsWithTables: false,
  footnoteHandling: 2 /* REMOVE_LINK */,
  internalLinkHandling: 0 /* CONVERT_TO_TEXT */,
  styleSheet: DEFAULT_STYLESHEET,
  htmlTemplate: DEFAULT_HTML_TEMPLATE,
  bareHtmlOnly: false,
  fileNameAsHeader: false,
  disableImageEmbedding: false
};
var CopyDocumentAsHTMLPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "smart-copy-to-mp",
      name: "\u590D\u5236\u9009\u62E9\u6216\u6587\u6863\u5230\u526A\u8D34\u677F",
      checkCallback: this.buildCheckCallback((view) => this.copyFromView(view, view.editor.somethingSelected()))
    });
    const beforeAllPostProcessor = this.registerMarkdownPostProcessor(async () => {
      ppIsProcessing = true;
    });
    beforeAllPostProcessor.sortOrder = -1e4;
    const afterAllPostProcessor = this.registerMarkdownPostProcessor(async () => {
      ppLastBlockDate = Date.now();
      ppIsProcessing = false;
    });
    afterAllPostProcessor.sortOrder = 1e4;
    this.addSettingTab(new CopyDocumentAsHTMLSettingsTab(this.app, this));
    this.setupEditorMenuEntry();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!this.settings.useCustomStylesheet) {
      this.settings.styleSheet = DEFAULT_STYLESHEET;
    }
    if (!this.settings.useCustomHtmlTemplate) {
      this.settings.htmlTemplate = DEFAULT_HTML_TEMPLATE;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  buildCheckCallback(action) {
    return (checking) => {
      if (copyIsRunning) {
        return false;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) {
        return false;
      }
      if (!checking) {
        action(activeView);
      }
      return true;
    };
  }
  async copyFromView(activeView, onlySelected) {
    if (!activeView.editor) {
      console.error("No editor in active view, nothing to copy");
      return;
    }
    if (!activeView.file) {
      console.error("No file in active view, nothing to copy");
      return;
    }
    const markdown = onlySelected ? activeView.editor.getSelection() : activeView.data;
    const path = activeView.file.path;
    const name = activeView.file.name;
    return this.doCopy(markdown, path, name, !onlySelected);
  }
  async copyFromFile(file) {
    if (!(file instanceof import_obsidian.TFile)) {
      console.error(`cannot copy folder to HTML: ${file.path}`);
      return;
    }
    if (file.extension.toLowerCase() !== "md") {
      console.error(`cannot only copy .md files to HTML: ${file.path}`);
      return;
    }
    const markdown = await file.vault.cachedRead(file);
    return this.doCopy(markdown, file.path, file.name, true);
  }
  async doCopy(markdown, path, name, isFullDocument) {
    console.debug(`Copying "${path}" to clipboard...`);
    const title = name.replace(/\.md$/i, "");
    const copier = new DocumentRenderer(this.app, this.settings);
    try {
      copyIsRunning = true;
      ppLastBlockDate = Date.now();
      ppIsProcessing = true;
      const htmlBody = await copier.renderDocument(markdown, path);
      if (this.settings.fileNameAsHeader && isFullDocument) {
        const h1 = htmlBody.createEl("h1");
        h1.innerHTML = title;
        htmlBody.insertBefore(h1, htmlBody.firstChild);
      }
      let htmlDocument = this.settings.bareHtmlOnly ? htmlBody.outerHTML : this.expandHtmlTemplate(htmlBody.outerHTML, title);
      htmlDocument = this.simplifyCodeBlocks(htmlDocument);
      htmlDocument = this.preprocessMarkdownList(htmlDocument);
      htmlDocument = this.applyInlineStyles(htmlDocument);
      const data = new ClipboardItem({
        "text/html": new Blob([htmlDocument], {
          type: ["text/html", "text/plain"]
        }),
        "text/plain": new Blob([htmlDocument], {
          type: "text/plain"
        })
      });
      await navigator.clipboard.write([data]);
      new import_obsidian.Notice(`\u590D\u5236\u6210\u529F\uFF01`);
    } catch (error) {
      new import_obsidian.Notice(`copy failed: ${error}`);
      console.error("\u590D\u5236\u5931\u8D25", error);
    } finally {
      copyIsRunning = false;
    }
  }
  simplifyCodeBlocks(htmlString) {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = htmlString;
    const codeBlocks = tempDiv.querySelectorAll("pre:has(> code)");
    codeBlocks.forEach((block) => {
      const codeElement = block.querySelector("code");
      if (codeElement) {
        const codeText = codeElement.textContent || codeElement.innerText;
        const pre = document.createElement("pre");
        const code = document.createElement("code");
        pre.setAttribute("style", "background: linear-gradient(to bottom, #2a2c33 0%, #383a42 8px, #383a42 100%);padding: 0;border-radius: 6px;overflow: hidden;margin: 24px 0;box-shadow: 0 2px 8px rgba(0,0,0,0.15);");
        code.setAttribute("style", 'color: #abb2bf;font-family: "SF Mono", Consolas, Monaco, "Courier New", monospace;font-size: 14px;line-height: 1.7;display: block;white-space: pre;padding: 16px 20px;-webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;');
        code.textContent = codeText;
        pre.appendChild(code);
        block.parentNode.replaceChild(pre, block);
      }
    });
    return tempDiv.innerHTML;
  }
  preprocessMarkdownList(content) {
    content = content.replace(/^(\s*(?:\d+\.|-|\*)\s+[^:\n]+)\n\s*:\s*(.+?)$/gm, "$1: $2");
    content = content.replace(/^(\s*(?:\d+\.|-|\*)\s+.+?:)\s*\n\s+(.+?)$/gm, "$1 $2");
    content = content.replace(/^(\s*(?:\d+\.|-|\*)\s+[^:\n]+)\n:\s*(.+?)$/gm, "$1: $2");
    content = content.replace(/^(\s*(?:\d+\.|-|\*)\s+.+?)\n\n\s+(.+?)$/gm, "$1 $2");
    return content;
  }
  applyInlineStyles(html) {
    const style = STYLES["wechat-default"].styles;
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    Object.keys(style).forEach((selector) => {
      if (selector === "pre" || selector === "code" || selector === "pre code") {
        return;
      }
      const elements = doc.querySelectorAll(selector);
      elements.forEach((el) => {
        if (el.tagName === "IMG" && el.closest(".image-grid")) {
          return;
        }
        const currentStyle = el.getAttribute("style") || "";
        el.setAttribute("style", currentStyle + "; " + style[selector]);
      });
    });
    const container = doc.createElement("div");
    container.setAttribute("style", style.container);
    container.innerHTML = doc.body.innerHTML;
    return container.outerHTML;
  }
  expandHtmlTemplate(html, title) {
    const template = this.settings.useCustomHtmlTemplate ? this.settings.htmlTemplate : DEFAULT_HTML_TEMPLATE;
    return template.replace("${title}", title).replace("${body}", html).replace("${stylesheet}", this.settings.styleSheet).replace("${MERMAID_STYLESHEET}", MERMAID_STYLESHEET);
  }
  setupEditorMenuEntry() {
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file, view) => {
      menu.addItem((item) => {
        item.setTitle("\u590D\u5236\u5230\u516C\u4F17\u53F7").setIcon("clipboard-copy").onClick(async () => {
          return this.copyFromFile(file);
        });
      });
    }));
  }
};
