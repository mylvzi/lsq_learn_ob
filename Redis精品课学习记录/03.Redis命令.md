> Redis使用起来就像是网络版本的哈希表
# 1.get set方法(最核心的命令)
`set` : set key value   不需要添加"",  存储数据时默认都是字符串
	成功:ok
	
`get`: 根据key获取value
	成功: value
	失败: nil  (访问一个不存储的key) ==null==
	


> Redis中命令不区分大小写

# 2.Redis全局命令
> 全局命令:对所有的数据结构都能进行操作的命令
> key都是string,value可以是多种数据类型

**keys** 
`keys pattern` :按照一定的匹配模式去匹配当前服务器上的key值
![[Pasted image 20250923121232.png]]

>**Warning**: consider `KEYS` as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use `KEYS` in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using [`SCAN`](https://redis.io/docs/latest/commands/scan/) or [sets](https://redis.io/docs/latest/develop/data-types/sets/).

尽量不要在生产环境中使用keys命令,1是因为生产环境上,key会非常多,keys pattern本质上是扫描整个Redis服务器上的所有key,而Redis又是单线程的,可能会导致Redis服务器崩溃
时间复杂度为O(N)




**exists**
`exists key [key ...]` 判断key是否存在  **返回存在的key的个数**

特殊情况:exists k1 k1  返回2
![[Pasted image 20250923135535.png]]

为什么要支持一次判断多个key呢?因为Redis传输数据是通过网络进行传输的,每执行一次命令就会产生一次网络传输,所以Redis后续支持了一次操作多个key的相关操作


**del**
`del key [k1 k2]`
删除指定的key,支持批量删除  返回成功删除的个数

**expire**
expire key seconds    给key设置过期时间   设置过期时间成功,返回1  设置失败,返回0

两个经典 的应用场景:
1. 验证码等等
2. 基于Redis实现分布式锁,设置一组特殊的一个key

**ttl**
ttl key   查看指定key的剩余过期时间
![[Pasted image 20250923141409.png]]

* 在Redis2.8之后,添加了-2应答
* ttl:time - to - live  存活时间

**type**

`type key` :返回key中存储的value的数据类型

# Redis过期策略的实现(经典面试题)

> 前言:通过expire命令可以给key设置过期时间,那么在Redis服务器中就会存在大量的含有过期时间的key,一旦过期,需要Redis服务器进行删除,如果不删除,就会占用内存空间
> 删除key就类似于Java中的垃圾回收机制,即Redis服务器采用什么策略去删除过期的key

在Redis中,主要是下面两种方式结合:
1. 定期扫描:定期对**一部分**key进行扫描,如果过期就执行del操作;
2. 惰性删除:什么时候再次用到,发现过期了,在执行删除,并返回0表示要使用的key不存在(类似于懒加载模式,什么时候用,什么时候创建,这里是什么时候用,什么时候删除)

定期扫描能够保证一些长期不使用的key能得到删除,除了上述两种方式以外,Redis还提供了一些淘汰策略来保证过期的key能及时得到删除


单例模式懒加载和Redis中惰性删除感觉很像,但本质目标是不同的:
* 单例模式懒加载: **节省初始化资源**,避免在类加载时就创建一个可能永远也用不到的实例
* Redis惰性删除:**节省cpu资源**,避免大量key过期需要删除导致线程阻塞

也解释了为什么直接删除呢?因为Redis本质上是一个单线程的服务器,执行命令/扫描资源等操作都是在一个线程中执行的,如果同一时间大量删除key可能会导致阻塞,影响主工作业务

# 定时器实现原理
> 使用定时器管理Redis中的key是一种高效的策略,但是Redis本身并没有通过这种方式实现,最大的原因是定时器的实现依赖于多线程,这和Redis单线程矛盾

**基于优先级队列**
> 过期时间越早,优先级越高  ttl越少,优先级越高

定时器实现方式  [多线程编程设计模式(单例,阻塞队列,定时器,线程池)_多线程设计模式-CSDN博客](https://blog.csdn.net/Mylvzi/article/details/135218801?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226d990fec76cac153738505309f9e705d%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=6d990fec76cac153738505309f9e705d&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-135218801-null-null.nonecase&utm_term=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4450)

阅读下Java中Timer类的实现方式  源码


**基于时间轮实现**

