下面是一篇结构完整、适合发布的技术博客内容，总结我们本阶段涉及的 **Redis 三剑客：缓存一致性、缓存穿透、缓存雪崩**。

---

# 从 0 到 1 理解 Redis 三剑客：缓存一致性、缓存穿透、缓存雪崩

在引入 Redis 作为缓存后，系统性能确实得到了显著提升。但缓存系统不是简单的“查不到就写进去”那么简单。

真正的工程挑战在于：

- 如何保证缓存不脏？
    
- 如何防止数据库被打爆？
    
- 如何避免大规模失效导致系统雪崩？
    

本文系统总结缓存系统中的“三剑客问题”。

---

# 一、缓存一致性问题

## 1. 问题本质

假设系统流程：

```
查缓存 → 没命中 → 查数据库 → 写缓存
```

如果发生更新操作：

```
更新数据库
```

但缓存未同步更新，则下一次查询仍会命中旧缓存数据。

这就是：

> 缓存脏数据问题

---

## 2. 常见更新策略对比

|策略|是否推荐|问题|
|---|---|---|
|更新 DB 后更新缓存|❌|并发下可能脏写|
|先删缓存再更新 DB|❌|可能被旧读覆盖|
|更新 DB 后删除缓存|✅|工程常用方案|
|双删策略|🔥|高并发优化|

---

## 3. 推荐方案：更新 DB 后删除缓存

```java
@Transactional
public void updateOrder(Order order) {
    orderMapper.update(order);
    redisTemplate.delete("order:list:" + order.getUserId());
}
```

### 为什么删除比更新更安全？

因为：

- 写操作远低于读操作
    
- 删除后，下次读会自动回源重建缓存
    
- 减少复杂的并发覆盖问题
    

这是典型的：

> Cache Aside Pattern（旁路缓存模式）

---

## 4. 双删策略（高并发增强版）

极端并发情况下：

1. A 更新数据库
    
2. B 读取旧数据
    
3. A 删除缓存
    
4. B 把旧数据写回缓存
    

缓存再次变脏。

解决方案：

```
更新 DB
删除缓存
sleep 100ms
再删一次
```

这叫“双删策略”，用于高并发核心链路。

---

# 二、缓存穿透

## 1. 什么是缓存穿透？

用户查询一个不存在的数据：

- Redis 没命中
    
- MySQL 没数据
    
- 不写缓存
    

如果攻击者不断请求不存在的 ID：

数据库会被持续击穿。

---

## 2. 解决方案一：缓存空值

```java
if (orders == null || orders.isEmpty()) {
    redisTemplate.opsForValue().set(key, "NULL", 1, TimeUnit.MINUTES);
}
```

这样：

- 第一次查 DB
    
- 后续直接命中缓存
    

优点：实现简单  
缺点：会占用少量缓存空间

---

## 3. 解决方案二：布隆过滤器（进阶）

布隆过滤器用于：

> 在访问数据库前判断 ID 是否可能存在

流程：

```
请求 → 布隆过滤器判断
      → 不存在 → 直接返回
      → 可能存在 → 查 Redis / DB
```

优点：

- 大规模防攻击
    
- 内存占用低
    

这是大厂常见做法。

---

# 三、缓存雪崩

## 1. 什么是缓存雪崩？

如果所有缓存：

```
TTL = 10 分钟
```

10 分钟后同时过期。

瞬间：

- Redis 大量 miss
    
- 所有请求打到数据库
    
- DB 连接打满
    
- 系统崩溃
    

---

## 2. 解决方案：随机过期时间

```java
long ttl = 600 + new Random().nextInt(60);
redisTemplate.opsForValue().set(key, value, ttl, TimeUnit.SECONDS);
```

让缓存过期时间分散开。

避免“集体过期”。

---

# 四、Redis 三剑客的核心思想

|问题|本质|解决核心|
|---|---|---|
|缓存一致性|数据同步|删除缓存|
|缓存穿透|查询不存在数据|缓存空值 / 布隆|
|缓存雪崩|集中过期|随机 TTL|

---

# 五、Redis 的角色定位

必须明确：

```
Redis = 缓存 / 状态存储
MySQL = 事实数据源
```

为什么不能用 Redis 存“订单真数据”？

- Redis 可能宕机
    
- 内存型数据库
    
- 不具备强事务保障
    
- 数据持久化不如 MySQL 稳定
    

Redis 的核心定位是：

> 提升读取性能，而不是替代数据库

---

# 六、工程级理解：缓存不是可靠层

一个成熟系统必须满足：

- Redis 挂了，系统仍能运行
    
- 缓存只是“加速器”
    
- 不能影响主链路
    

正确做法：

```java
try {
    cache = redisTemplate.opsForValue().get(key);
} catch (Exception e) {
    log.error("Redis error", e);
}
```

缓存失败 → 回源数据库。

---

# 七、总结

当你真正理解“Redis 三剑客”时，你已经完成了从 CRUD 开发到系统工程的第一步。

缓存不是简单技术，而是一套：

- 数据一致性设计
    
- 高并发思维
    
- 容错能力设计
    

的综合能力体现。

---

如果继续深入，下一步应进入：

- 分布式锁
    
- 热点 Key 处理
    
- 多级缓存
    
- Redis + MQ 的一致性保障
    

这才是后端系统设计真正的进阶阶段。