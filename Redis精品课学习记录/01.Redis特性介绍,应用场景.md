> Redis是在内存中存储数据的中间件
> 数据库,缓存,消息队列

## 核心特性
**In-memory data structure**:通过特定的数据结构在内存中存储数据
键值对的数据结构,非关系型数据库

**Programmability**:针对Redis脚本,可以直接通过命令交互,也可以通过脚本语言操作Redis,批量执行操作(Lua脚本)

**Extensibility**:可拓展性,在原有的功能基础上在进行拓展 ,支持更多的数据结构或者更多的命令

**Persistency**:持久化  内存上的数据已丢失,Redis会将数据存储到硬盘上,对内存数据进行备份;Redis重启后,从磁盘中获取数据,保证恢复到原先的状态

**Clustering**:集群化,支持水平拓展,类似于分库分表,就是可以引入多个Redis节点哈哈(毕竟内存的数据是有限的)

**High availabilit**y:高可用性  自身支持"主从节点",一个节点挂掉了,另一个节点可以顶上去,提升系统的稳定性

Quick:
1. 存储在内存中,接近寄存器,天然读取速度就快
2. Redis核心功能都是比较简单的逻辑,核心操作都是一些简单的操作内存数据结构
3. 从网络角度,Redis使用了IO多路复用(epoll)
4. 从线程角度,Redis使用的是单线程,不存在线程开销带来的性能下降(StringBuilder和StringBuffer的区别哈哈)

## 应用场景

**Real-Time data store**:实时数据存储,Redis存储是全量数据数据库,适用于**低延迟,高吞吐**数据存储
**Caching & session storage**: 数据冷热分离,存储的是热点数据,加快热点数据的访问;会话存储:
使用单独一个Redis服务器存储会话,主要是为了解决分布式系统下会话存储的问题
![[Pasted image 20250921121608.png]]
通过cookie-session机制存储用户的会话信息.cookie中存储的是由服务器生成的sessionid,服务器中的session存储的才是具体的用户信息,此后用户的每次请求都会在http报文中添加cookie字段,从而维持一直登录的状态

在分布式系统中,负载均衡器会将上述请求按照一定的算法分配给不同的服务器.假如第一次请求将会话信息存储到服务器A,此时服务器A中存储了会话信息,用户的下一次请求被分给了服务器B,那此时服务器B内部没有响应的会话信息,还需要重新存储并返回sessionid

如何解决的呢?
1. 修改负载均衡器的分配机制,按照userid进行分配,映射到存储对应userid会话信息的服务器上
2. 将会话信息单独提取出来,放到Redis服务器中,即解耦,又能加快响应速度

**Streaming & messaging**:   网络版本的生产者,消费者模型;分布式系统中,数据的传输是通过网络传输的,Redis可以作为一个消息队列,异步解耦消息在网络中的传输(这也是Redis设计的初心)

# 总结
主要的缺点:因为数据存储在内存之中,存储的数据量是有限的,无法存储大量的数据

而且,技术的选型一定要明白技术的原理
假如现在是一个单机架构,我们需要存储`用户名-视频数` 这样一个映射关系,存储方式有以下两种方式:
1. 直接创建hash map在内存中存储数据
2. 引入Redis,在Redis服务器中存储

1相较于2的速度更快!虽然Redis最大的特点就是快,但是是对比出来的;Redis作为一个数据库,相较于MySQL这种关系型数据库速度肯定更快,但是跟直接在内存中存储数据,性能还是差点

因为通过Redis存储的数据,需要通过网络传输才能操作