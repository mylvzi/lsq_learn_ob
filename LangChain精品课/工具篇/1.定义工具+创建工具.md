> 工具调用的本质就是`拓展模型的边界`
> 利用外部工具, 将要获取的数据得到,传递给LLM进行分析
> `工具schema : 工具名称 工具参数  工具描述` : 传递给LLM工具元数据, 无论是通过哪种方式调用,这三个metadata都是必须的


# 2.创建工具
## 2.1@tool创建工具
```python
from langchain_core.tools import tool  
@tool  
def ADD(a: int, b: int) -> int:  
    """两整数相加  
    :param a: 第一个参数, 整形  
    :param b: 第二个参数,整形  
    :return: a + b的和  
    """    return a+b  
  
print(ADD.invoke({"a":1, "b":2}))
```
* @tool的作用就是将python函数/接口转换为Langchain工具
* 类型提示和docstr是必须的

`理解`
1. tool的本质是要求我们`定义一个工具schema`, 是Langchain中链接LLM与外部世界的IDL(Interface Defination Language)
2. 编写的tool shcema之所以很复杂,格式严格(类型提示 + docstr), 本质是为了更好的`引导大模型`,是一种`软约束`(不同于编译器的硬约束)
3. Langchain中所有的工具类的基类是`BaseTool`,详见 : https://reference.langchain.com/python/langchain/tools/?_gl=1*nehb9l*_gcl_au*MTc4MDA3ODkxLjE3Njc1MjczMjA.*_ga*NDk2NTk2NDM0LjE3Njc1MjczMjI.*_ga_47WX3HKKY2*czE3Njc1MjczMjIkbzEkZzEkdDE3Njc1Mjc1NzckajYwJGwwJGgw#langchain.tools.BaseTool
## 2.2使用Pydantic应对复杂的输入输出
```python
from langchain_core.tools import tool  
from pydantic import BaseModel, Field  
class AddInput(BaseModel):  
    """Add two integers"""  
  
    a: int = Field(..., description='First input')  
    b: int = Field(..., description='Second input')  
  
class AddOutput(BaseModel):  
    """:return two"""@tool(args_schema=AddInput) #args_shcema模式是none, 也可以传递JSON Schema  
def Add(a: int, b: int):  
    return a+b  
  
  
print(Add.invoke({"a": 1, "b": 2}))  
print(AddInput.model_json_schema()) # pydantic提供自描述能力  生成标准式schema
```
* python的类型检查是`假的`, PyDantic提供了一种强约束能力, 同时可以生成结构化的JSON schema
![[Pasted image 20260104204143.png]]

## 2.3依赖Annotated
```python
from langchain_core.tools import tool  
from typing_extensions import Annotated  
  
@tool  
def add(  
a: Annotated[int, ..., "First integer"],  
b: Annotated[int, ..., "Second integer"]  
) -> int:  
    """Add two integers."""  
    return a + b  
  
  
print(add.invoke({"a": 1, "b": 2}))
```
# 3.StructuredTool类的from_function
```python
from typing import Tuple, List  
from langchain_core.tools import StructuredTool  
  
def add(a: int, b: int)->Tuple[str, List[int]]:  
    """两数相加  
  
    :param a:    :param b:    :return:  
    """    
    nums = [a, b]  
    content = f"{a} + {b}的结果是{a + b}"  
    return content, nums  
  
add_tool = StructuredTool.from_function(  
    func=add,  
    response_format="content_and_artifact"  # 工具响应格式  
)  
  
print(add_tool.invoke(  
{  
	"name": "ADD_CONTENT_AND_ARTIFACT",  
	"args": {"a": 2, "b": 3},  
	"id": "123", # 必须，与⼯具调⽤关联的标识符，将⼯具调⽤请求与⼯具调⽤结果相关联。  
	"type": "tool_call", # 必须  
}  
))  
print(add_tool.invoke({"a": 1, "b": 2}))
```

* @tool注解的本质就是通过StructuredTool的from_function进行转换的

