>前置知识

**几个结论**
* 所有的网络都是IP网络,IP协议所在的网络层决定了网络通信的方式（UDP OR TCP）
* 数据链路层和物理层每一个设备都是不一样的，但是向上封装的网络数据包都是相同的
* 也可以说，IP协议屏蔽了底层网络的差异（以太网 OR WLAN）本质上也是一种虚拟化技术
* MAC地址在局部是有效的,主要负责在两个主机之间通信

**SOCKET通信**
* SOCKET = IP + PORT
* 网络通信本质上是两台主机间的进程通信，进程通信的核心是`看到同一份共享资源`,这个共享资源就是网络
* 网络通信的操作无非就两点,从网络中获取数据 OR 向网络中输入数据

# UDP Socket
>如何通信: Server  Client
>Server:
>1. 创建socket
>2. 绑定socket, bind

## 创建socket
```c
int socket(int domain, int type, int protocol);
domain : communication domain  protocal family  在哪个范围内部交流  AF_INET
type : communication semantic  以什么"语义"交流  用什么方言通信  SOCK_DGRAM(UDP通信)
return : socket_fd  linux中一切且文件,使用socket_fd标识socket
```

创建socket
```c++
        // 1.创建socket       domain   type
        _socketFd = ::socket(AF_INET, SOCK_DGRAM, 0);
```

## 绑定socket
创建完socket仅仅是规定了使用什么方式通信,还无法和外界进行通信,因为外界不知道怎么找到你!
使用`bind`,给socket起一个名字,让外界通过这个`名字`来定位此主机的socket



```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
           struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
           }
struct sockaddr_in {
    sa_family_t    sin_family;   // 地址族
    in_port_t      sin_port;     // 16位端口号（网络字节序）
    struct in_addr sin_addr;     // IPv4 地址
    unsigned char  sin_zero[8];  // 填充，保持与 sockaddr 对齐
};
struct in_addr {
    uint32_t s_addr; // IPv4 地址（网络字节序）
};
```


![[Pasted image 20260121230937.png]]

* bind的本质 : 建立socket和地址之间的映射关系*