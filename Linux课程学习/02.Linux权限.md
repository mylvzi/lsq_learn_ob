# Linux权限

## 1.什么是权限
> 权限决定的是 **有无和能不能**的问题  
> 作用是拦住一部分人

## 2.权限的本质
**权限和什么有关**
1. 人 : 你是谁不重要,关键在于你的**角色**  比如刷门禁,你是谁不重要,只有你是业主, 我才能给你开门
2. 事物的属性 : 必须指定在哪个事物上的权限,比如不能在爱奇艺刷题,不能在leetcode看视频 ;我可以管理我的房间,别人不能进入到我的房间;因为我对这个房间具有**所有权**,但是你妈妈是root用户,可以全部访问  

权限 = 角色权限 + 事务属性
## 3.Linux中的用户
### 分类

root : 超级管理员  不受权限约束
其他(普通用户) : 


 > su : 切换root用户  输入的密码是root用户的密码
 > su - : 切换root用户, 并显示上次登录信息
 > ctrl d : 退出登录
 > root --> 普通用户 :  su 用户名   查看有哪些用户 : ls /home
 > sudo : 指令提权  不是root用户,但是想以root的权限执行操作  默认云服务器是无法直接执行的
 > sudo 的 用户是需要进行 **白名单配置的**

### Linux中的角色

拥有者 user

所属组(group) : 同一组可以看到代码,other无法看到;可以更加细致的完成 权限管理

other : 除了 user和 group 就是other

Linux中的角色是需要具体的人来进行扮演的!  权限约束的不是人,而是具体的角色  具体的人是不同的角色(除了root用户)


## 4.Linux中的文件权限
> ll展示的第一列一共有 10 个字符
> 第一个字符表示文件的类型 : d 目录文件  - : 普通文件
> 剩下的是三三一组,分别对应 拥有者 所属组 other
> 所以 权限 = 角色 + 文件权限属性
![[Pasted image 20250930114548.png]]

**文件属性权限**
r : 读权限  
w : 写权限
x : 执行权限

有权限 -- 就是对应的字符 r/w/x 如果没有就是 -, 权限存在的意思是为了保护文件不被其他人访问
### 1.修改文件权限
**谁能修改文件权限**
1. 拥有者 : 本身就是文件的所有者,我有处理的权限
2. root用户 : 超级管理员,无视一切

**修改权限命令**
> chmod u+rw file
> chmod g-r file
> chmod o-xr file
> chmod u-w,g+w file  支持批量修改多个人,多个权限
> chmod a+r file : 给所有人都加上 r 权限
> ![[Pasted image 20250930114851.png]]
### 2.对比权限 有无
> **从账号来说**
> 1. 对于普通用户,是存在 权限约束的
> 2. 对于 root 用户, 是不存在权限约束的
> **用户在匹配时只匹配一次** : 当一个用户既是 拥有者,又是 所属组时, 只会匹配拥有者, 只要匹配成功就不会向后匹配


### 3.修改用户角色
更改命令:
* chown : 更改拥有者  chown root:root filename  同时修改所有者 和 所属组
* ![[Pasted image 20250930113912.png]]
* chgrp : 更改所属组(只能修改所属组)
* ![[Pasted image 20250930114003.png]]
* ![[Pasted image 20250930114057.png]]
* chmod : 更改文件属性


修改角色的两种方式:
1. 切换为root用户
2. sudo chown : 短暂以root权限执行命令

用八进制表示文件的权限(面试题常考)
原理 :
	我们知道, 对于文件权限 字母表示 有权限 (1), - 表示没有权限(0), 对于一个角色所拥有的权限来说,无非就三个 : r w x, 我们可以使用 1 / 0 来表示某个角色的权限
	比如 :
	![[Pasted image 20250930115356.png]]

基于以上原理, 我们也可以通过**八进制数字**的方式修改各个角色的权限:
比如将给所有的角色都赋予所有的权限, 即 : rwxrwxrwx -- 777
![[Pasted image 20250930115622.png]]


**通过ls -l查看文件  也能查看到文件的权限  包括角色权限和自身属性权限**

### 4.文件类型
> windows中 通过 后缀 区分不同的文件
> **Linux系统中 不通过** 后缀区分 文件类型  [不是说Linux不用后缀]
> 	验证: 更改为不同的后缀,都能执行对应文件
> - : 普通文件   ,文本文件,可执行程序, 源文件, 库 都叫做普通文件
> d : 目录文件

下面的命令不是很重要 : 
> b : 块设备文件    磁盘文件  ls /dev/vda
> ![[Pasted image 20250930145050.png]]
> c : 字符设备文件  显示器文件  显示器本质上就是字符设备  ls /dev/pts  虚拟终端从设备
> ![[Pasted image 20250930145109.png]]
> p ; 管道文件   进程间通信
> ![[Pasted image 20250930145310.png]]
> ![[Pasted image 20250930145429.png]]
> l :链接文件  可以理解为 windows上的快捷方式  建立一个链接文件 指向 目标文件
> ![[Pasted image 20250930145214.png]]

![[Pasted image 20250930141634.png]]

> Linux不区分文件类型,但是Linux上面的工具会区分  比如 gcc命令 只能编译 .c文件


**如何理解 可执行权限  x**
> 能执行 = 具有可执行权限(x) + 你本身就是一个可执行文件  我不拦着你 执行,但是你能不能执行是你自己的问题
> 具有x权限本身 是 能执行的必要 条件


# 目录权限
> 目录本身也是一个文件,具有上述讲的文件基本属性  角色 + 文件本身属性
## 进入一个目录需要什么权限  需要X权限  即执行权限
> 目录的 r 权限 :  决定用户能否查看当前目录下文件的权限  但是可以创建文件(w权限)
> 目录的 w 权限 :  决定用户能否在当前目录下增删改文件的权限  但是可以访问文件(r权限)
> 目录的x权限 : 决定能否进入目录

文件 = 内容 + 属性  目录本质上也是一个文件,目录的属性很好理解,但是**目录的内容是什么?**
目录的内容 = 目录下所包含所有文件的详细数据信息
* `r` : 能够查看目录的内容 -- 查看所有文件的详细数据信息  ls
* `w` : 能够修改目录的内容 -- 修改所有文件的详细数据信息  增删改
* `x` : 创建目录时默认就带有x权限
![[Pasted image 20250930144202.png]]
删除 目录 的 x权限,无法进入目录

**删除r权限,可以进入,但无法查看目录内容,可以创建文件**
![[Pasted image 20250930144340.png]]

**删除w权限,可以进入,但是无法修改目录内容,可以查看目录内容**
![[Pasted image 20250930144453.png]]
补充:
1. 这里的w权限包含三方面:
		创建文件:touch mkdir
		重命名文件 : mv
		删除文件: rm -rf
	但是可以使用`chmod` 修改目录下文件的权限,上面我们说过,判断能不能修改权限,就两方面:
	1. root用户
	2. 文件的所有者
	也就是说跟你是什么权限是无关的!
# Linux创建文件和目录时默认权限为什么不一样
当我们新创建目录和文件时,默认会被赋予一些权限(普通用户)
![[Pasted image 20250930163707.png]]
**umask**
> umask : Linux中权限掩码  过滤掉在umask中出现的权限
> umask 0000 可以直接修改umask
> umask 0777 : 创建的所有文件都是--- --- --- 
> 计算方式 : 最终权限 = 默认权限 & (~umask)

![[Pasted image 20250930163655.png]]
* 综上 : 新创建的目录/文件的默认权限的值取决于 umask的值是多少, 是默认权限和 & (~umask)的结果

为什么要这么设计呢?
1. 对于目录 : rwx rwx r-x , other用户没有 w 权限, 也就意味着非grp的用户是无法在本目录下创建,修改,删除文件的;也是为了防范外部用户对目录详细数据进行修改. 但是为了保证other能够进入当前目录,需要给当前目录设置 x权限
2. 对于普通文件 : rw- rw- r--, 所有的用户都没有x权限;other用户没有写的权限

>   删除一个文件和目标文件没有关系  -- > 能否删除一个普通文件,取决于当前文件所处目录以及角色是否有 w 权限  所以,在 /home/lsq 目录下,可以普通用户可以删除 由 root 用户创建的文件
>   在这个目录下,lsq属于 拥有者, root用户是 other, 所以说 对于自己创建的目录,别人默认是不具有 w权限的, 即默认other用户是不能删除 文件的  只能查询文件   

那Linux中的用户不能互相删除吗?Linux中也做了相应的防范措施  根本就进不来
![[Pasted image 20250930164249.png]]
对于家目录来说,天然就排外
ll /home
> 文件能否被删除取决于在那个目录下  这才能证明目录是自己的
> 在自己的家目录下,可以随便删除文件  别人也有权限在我的家目录下创建文件
> **能否删除一个文件,取决于该用户在文件所处目录下是否有w权限.如果有就可以删除**

> 那在Linux中,需要 多用户共享文件怎么办
> 	1. 首先不能在用户的家目录创建  因为家目录本身就具有 排外的 权限 
> 	2. 只能在 非用户目录下创建  就是非home就行 只要把目录的权限全部放开就行
> 	3. 让root用户在根目录下创建一个目录就行
> **第三方问题**:
> 	描述 : A,B想要实现文件的共享,在非各自家目录下创建了共享目录,这个目录的所有者是root,A,B都属于other,权限都是rwx
> 	现在 A创建了一个文件, 想要和B进行共享,现在有个用户C,他也可以进入到当前目录下,由于他也具有w权限,所以他可以删除这个A,B共享的文件,如何解决这个问题呢,  关键问题在于other开放的权限太大了, 其他人可以查看,访问文件,但是我不想让他删除文件 -- 粘滞位

可以通过给目录设置**粘滞位**的方式来解决上述问题,给目录设置粘滞位后,该目录下的文件只能下面两种角色删除:
1. 超级管理员 root
2. 该目录的所有者
> chomod +t dir1
