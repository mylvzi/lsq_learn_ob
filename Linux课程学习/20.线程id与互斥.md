# 一.深刻理解tid
![[Pasted image 20251222233803.png]]

>我们需要给用户呈现的是`线程`,  但是Linux只有轻量级进程, pthread库对轻量进程的封装
>站在内核和pthread库,都需要一个标识符来管理`线程`
* Lwp : 内核级标识符,调度执行的基本单位
* tid(pthread_self()) : 用户级别,线程控制块的唯一标识符

创建线程 -- 需要使用pthread库 -- 需要把这个库从磁盘中加载到内存中并进行映射 -- 映射到栈堆之间的共享区(动态库的加载)[[15.动静态库#附加问题 动态库的加载 -- 可执行程序和地址空间]]
由于可能存在多个线程, 所以都需要使用pthread库, 所以pthread库本质上是一个动态库,so文件
![[Pasted image 20251223104636.png]]
![[Pasted image 20251223104743.png]]
所以,pthread库的链接就是一个动态库的链接
## pthread库对于线程的描述与组织
pthread库也要对创建出来的线程进行管理 -- 先描述再组织
描述线程 : struct Tcb(thread control block) 线程控制块
组织 : 类似于数组
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>

// 线程状态枚举
typedef enum {
    THREAD_READY,      // 就绪态
    THREAD_RUNNING,    // 运行态
    THREAD_BLOCKED,    // 阻塞态
    THREAD_TERMINATED  // 终止态
} thread_state_t;

// 调度策略枚举
typedef enum {
    SCHED_NORMAL,
    SCHED_FIFO,
    SCHED_RR
} sched_policy_t;

// CPU寄存器上下文(简化版)
typedef struct {
    unsigned long rsp;  // 栈指针
    unsigned long rbp;  // 基址指针
    unsigned long rip;  // 指令指针
    unsigned long rax;  // 通用寄存器
    unsigned long rbx;
    unsigned long rcx;
    unsigned long rdx;
} cpu_context_t;

// 栈信息
typedef struct {
    void *stack_base;      // 栈基址
    size_t stack_size;     // 栈大小
    void *stack_pointer;   // 当前栈指针
} stack_info_t;

// 线程特定数据节点
typedef struct tsd_node {
    pthread_key_t key;
    void *data;
    struct tsd_node *next;
} tsd_node_t;

// 清理处理程序节点
typedef struct cleanup_node {
    void (*routine)(void *);
    void *arg;
    struct cleanup_node *next;
} cleanup_node_t;

// 简化的TCB结构
typedef struct thread_control_block {
    // 基本标识
    pthread_t tid;              // 线程ID
    pid_t lwp_id;              // 轻量级进程ID (Linux中的实际进程ID)
    
    // 线程状态
    thread_state_t state;       // 当前状态
    int detached;              // 是否分离 (0=joinable, 1=detached)
    
    // CPU上下文
    cpu_context_t context;      // 寄存器上下文
    
    // 栈信息
    stack_info_t stack;         // 栈相关信息
    
    // 调度信息
    sched_policy_t sched_policy; // 调度策略
    int priority;               // 优先级
    
    // 线程函数和参数
    void *(*start_routine)(void *);  // 线程函数
    void *arg;                       // 线程参数
    void *return_value;              // 返回值
    
    // 信号相关
    sigset_t sigmask;           // 信号屏蔽字
    sigset_t pending_signals;   // 待处理信号
    
    // 线程特定数据
    tsd_node_t *tsd_list;       // 线程特定数据链表
    
    // 清理处理程序
    cleanup_node_t *cleanup_stack; // 清理函数栈
    
    // 同步相关
    pthread_mutex_t *waiting_mutex;  // 正在等待的互斥锁
    pthread_cond_t *waiting_cond;    // 正在等待的条件变量
    
    // 错误码
    int errno_value;            // 线程局部errno
    
    // 链表指针(用于线程管理)
    struct thread_control_block *next;
    struct thread_control_block *prev;
} tcb_t;

// 初始化TCB
tcb_t* tcb_create(void *(*start_routine)(void *), void *arg) {
    tcb_t *tcb = (tcb_t *)malloc(sizeof(tcb_t));
    if (!tcb) {
        return NULL;
    }
    
    // 初始化基本信息
    tcb->tid = pthread_self();
    tcb->state = THREAD_READY;
    tcb->detached = 0;
    
    // 初始化栈信息
    tcb->stack.stack_size = 8 * 1024 * 1024; // 8MB默认栈大小
    tcb->stack.stack_base = malloc(tcb->stack.stack_size);
    tcb->stack.stack_pointer = tcb->stack.stack_base + tcb->stack.stack_size;
    
    // 初始化调度信息
    tcb->sched_policy = SCHED_NORMAL;
    tcb->priority = 0;
    
    // 设置线程函数
    tcb->start_routine = start_routine;
    tcb->arg = arg;
    tcb->return_value = NULL;
    
    // 初始化信号
    sigemptyset(&tcb->sigmask);
    sigemptyset(&tcb->pending_signals);
    
    // 初始化链表
    tcb->tsd_list = NULL;
    tcb->cleanup_stack = NULL;
    tcb->waiting_mutex = NULL;
    tcb->waiting_cond = NULL;
    
    tcb->next = NULL;
    tcb->prev = NULL;
    
    return tcb;
}

// 销毁TCB
void tcb_destroy(tcb_t *tcb) {
    if (!tcb) return;
    
    // 释放栈空间
    if (tcb->stack.stack_base) {
        free(tcb->stack.stack_base);
    }
    
    // 释放线程特定数据
    tsd_node_t *tsd = tcb->tsd_list;
    while (tsd) {
        tsd_node_t *next = tsd->next;
        free(tsd);
        tsd = next;
    }
    
    // 释放清理函数栈
    cleanup_node_t *cleanup = tcb->cleanup_stack;
    while (cleanup) {
        cleanup_node_t *next = cleanup->next;
        free(cleanup);
        cleanup = next;
    }
    
    free(tcb);
}
```
1. 使用`pthread_t tid`来唯一标识一个tcb
2. 每个线程有自己的`栈信息`

>理解为什么join能拿到线程的退出结构`void *return_value; // 返回值`

新线程会将退出信息存储到`return_value`变量中, 是一个内存地址, 使用一个二级指针来指向这个地址,所以join的线程就可以拿到线程的退出值

> 每一个线程拥有自己独立的栈 -- 本质上实在自己的线程控制块内部开辟一段内存作为栈区
线程的栈大小本质就是一个线程的属性, 就是tcb的属性
```c
    // 初始化栈信息
    tcb->stack.stack_size = 8 * 1024 * 1024; // 8MB默认栈大小
    tcb->stack.stack_base = malloc(tcb->stack.stack_size);
    tcb->stack.stack_pointer = tcb->stack.stack_base + tcb->stack.stack_size;
```
![[Pasted image 20251223111729.png]]

>理解pthread_create
```scss
pthread_create()  用户态
		↓
分配栈 + TCB
		↓
初始化TCB字段
		↓
clone()创建与tcb一一对应的lwp
		↓
子线程启动入口(strat_routine)
```

>线程的局部存储
>线程是共享进程的虚拟地址空间的, 如果存在一个全局变量`g_val`,对他的修改,是所有线程可见的

```c++
#include <iostream>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdint.h>
int g_val = 100;
class Thread_Info
{
public:
    pthread_t tid;
    std::string name;
};
void* func(void* arg)
{
    std::string name = *(std::string*)arg;
    while(true)
    {
        std::cout << name <<" , g_val = : " << g_val << std::endl;
        sleep(1);
    }
    return NULL;
}

int main()
{
    Thread_Info* t1 = new Thread_Info();
    Thread_Info* t2 = new Thread_Info();
    t1->name = "Thread-1";
    t2->name = "Thread-2";
    
    pthread_create(&t1->tid, NULL, func, (void*)&t1->name);
    pthread_create(&t2->tid, NULL, func, (void*)&t2->name);
    
    while(true)
    {
        std::cout << "main thread, g_val = : " << g_val << std::endl;
        sleep(2);
        g_val++;
    }

    pthread_join(t1->tid, NULL);
    pthread_join(t2->tid, NULL);
    std::cout << "Join Done..." << std::endl;
    return 0;
}
```

![[Pasted image 20251223114507.png]]

如果一个变量是全局的, 一定能被所有的线程共享

`__thread` int一旦被修饰,就会存住在线程局部存储  存储在各自的局部存储空间内部
`__thread是gcc的扩展关键字,用于实现线程的TLS(线程局部存储), 让每个线程拥有变量的独立副本`
可以理解为是一种`编译手段`

![[Pasted image 20251223114944.png]]



封装线程 ; 再次理解cancel

# 线程的互斥
>多个线程对于共享资源的访问,可能会存在**数据不一致问题**
>需要对共享资源进行保护,如何保护呢
>1. 互斥 : 在同一时刻, 只能有一个线程访问资源
>2. 同步

`通过加锁解决数据不一致问题`[[17.命名管道#信号量的理解(初步)]]

## 锁
### 1.认识锁和锁的接口
```c
#include <pthread.h>
// 创建锁
pthread_mutex_t lock;

// 初始化锁
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
           const pthread_mutexattr_t *restrict attr);// 锁的地址  锁的属性
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;// 如果锁是全局的(static, 使用此方法初始化)
// pthread_mutex_init — destroy and initialize a mutex
// 这里的destroy 不是释放资源, 而是允许我们对之前的锁进行初始化!

// 销毁锁
int pthread_mutex_destroy(pthread_mutex_t *mutex);

// 加锁和解锁
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
![[Pasted image 20251225104321.png]]
* 加锁的过程一定是**原子的**, 锁本身也是一种共享资源(需要被所有线程看到)  就和信号量(semphore)一样, sem本质上就是一个计数器, 计数器的值本身就是共享资源的个数,对sem进行保护?pv操作一定是原子的
* 拥有锁资源的线程,在执行临界区代码时, 也可以被切换, 但是其他线程还是无法访问临界区资源(没有释放锁资源)

### 2.从汇编角度理解加锁

先回顾存在线程不安全的代码`cnt++`
```asm
mov eax, cnt  // 1.从内存加载cnt到eax寄存器  load
add eax, 1    // 2.执行+1操作               add
mov cnt, eax  // 3.从寄存器将cnt的值写入到内存save
```
* 一个`++`操作, 对应三条汇编指令, 从底层上来说就不是`原子的`
* 一条汇编指令 = 一个原子操作

> **我们通过检查原子交换返回的“旧值”（现在在 RAX 中）是否为 0，来判断是否成功获取了锁。**
- 旧值 == 0 → 成功（原来没人持锁）
- 旧值 == 1 → 失败（别人已经持锁）
**lock的汇编伪代码**
![[Pasted image 20251225135140.png]]
`加锁的伪汇编代码`
```asm
mov rax 1  // 将rax寄存器的值预设为1  表示接下来尝试占用锁资源

lock:
	xchg rdi, rax  // 将内存上lock变量和寄存器rax的值进行交换(此指令是原子的, 会锁住内存总线)
				  //  核心指令  rax会记录旧值
	if(rax == 0) return 0;
	else 挂起等待;	
```
* rax和rdi交换后, rax存储的是lock变量的旧值, 如果是0, 证明在此汇编语句之前, 锁资源没有被占用
* 如果为1, 证明锁资源被占用, 需要加入等待队列
`解锁的伪汇编代码`
```asm
mov rdi 0
唤醒等待的线程
```
* 直接将内存上的lock变量设置为1即可*

`加锁成功` : 判断成功 -- 成功返回
`加锁失败` : 判断失败 -- 阻塞等待


>那如何理解线程切换呢?
>持有锁资源的时候, 也会发生线程切换

只要持有锁的线程不执行unlock, rdi的值一直是1,其他线程在`if(rax == 0)`时,都会判断失败,都会阻塞等待



### 3.锁的三种使用风格
```c
// 1.局部变量版
pthread_mutex_t lock;
pthread_mutex_init(&lock);
pthread_mutex_lock(lock);// 加锁
// ...临界区代码
pthread_mutex_unlock(lock);// 解锁

// 2.全局变量版本
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_init(&lock);
pthread_mutex_lock(lock);// 加锁
// ...临界区代码
pthread_mutex_unlock(lock);// 解锁

// 3.RAII风格(Resource acquisition is Initialization  资源获取即初始化)
class LockGuard
{
public:
	pthread_mutex_t _mutex;
	
public:
	LockGuard(pthread_mutex_t mutex):
		_mutex(mutex)
	{
		pthread_mutex_init(&_mutex);
	}
	
	~LockGuard(pthread_mutex_t mutex)
	{
		pthread_mutex_destroy(&mutex);
	}
};
```