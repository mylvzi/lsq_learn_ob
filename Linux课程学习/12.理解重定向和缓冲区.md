
# 重定向
 >更改文件描述符表下标中的内容 -- 更改fd中存储的file对象的地址
 
 dup2(oldfd, newfd)   : 把oldfd指向的"打开文件(file objetc)" 赋值给newfd, 让newfd也指向同一文件,让两个fd同时指向同一个文件

通过这个调用就可以实现**文件重定向**, dup2(fd, 1), 将stdout重定向到fd所指向的打开的文件

这两个fd会共享文件的offset和file status flag
# 缓冲区
> 是什么 ; 缓冲区就是一段内存空间
> 为什么 : 给上层提供高效的IO体验, 间接提高整体的效率
> 分类 : 用户级的缓冲区   内核级的缓冲区
> 用户级的缓冲区 -- 解耦 ,提高效率 -- 减少用户态和内核态的切换,刷新IO的效率
> 内核级的缓冲区 -- 解耦,提高效率 -- 减少访问磁盘的时间, 减少空等

**缓冲区的刷新策略 : 涉及到什么时候进行数据的更新**
1. 立即刷新   fflush fsync  无缓存
2. 行刷新  显示器文件   为了符合人类的阅读习惯  遇到\n就直接刷新的操作
3. 全缓冲   缓冲区写满,才刷新, 普通文件
4. 特殊情况 ; 进程退出, 系统会自动刷新操作
这里说的刷新策略指的都是用户级别缓冲区的刷新策略

fork之后为什么会在文件中打印了两次内容
![[Pasted image 20251128161306.png]]
本质上是刷新策略发生了变化   隐式的发生了刷新策略的变化
原先是**行刷新**,但是重定向到 log文件中, 对于普通文件, 刷新策略是**全缓冲**, 也就是缓冲区满/进程退出会执行刷新操作, fork之后, 父子进程共享数据, 在父子进程退出时, 都会执行一次刷新操作, 从而向log中存入两次数据
**每个打开的文件都有自己的缓冲区**

## 2.封装一下简单库
>自定义实现C语言文件库
![[Pasted image 20251128162814.png]]
![[Pasted image 20251130111959.png]]
**fwrite**
![[Pasted image 20251128164414.png]]
写入操作的本质是**拷贝**, 将数据拷贝到文件缓冲区中, 时间合适, 就执行刷新策略
![[Pasted image 20251130111528.png]]

**fopen**
![[Pasted image 20251130112054.png]]


**对close的理解**
![[Pasted image 20251128170039.png]]
* close成功并不会保证数据被存入到磁盘之中, 因为内核是将数据存储到内核缓冲区之中, 等待时机去写入(有可能**延迟写入**)
* 如果想确保在close之后, 必须被物理的存储到磁盘之中, 可以使用fsync
* 每次write后, 内核会把数据放入到**Page cache**中, 并将其标记为**dirty**, 已经被修改, 但是还未写入磁盘的数据页面, 会有专门的**内核后台线程**负责写入这些数据
![[Pasted image 20251130111712.png]]
文件刷新的本质其实是拷贝   拷贝到对应中文件流的缓冲区之
sprintf 的参数理解  输出形参数  打印的过程本质上是向显示器文件打印字符  想显示器文件写入字符  sprintf就是向其他文件写入字符数据

**文件的刷入**
![[Pasted image 20251130111734.png]]
* 底层调用write函数, 将数据刷入到内核级缓冲区之中, 然后将用户级缓冲区清空(注意之前说的, 一个成功的write系统调用并不会保证数据刷入到磁盘中, 只是将数据存入到内核级缓冲区之中)
**C语言为什么在FILE中提供用户级的缓冲区 -- 减少底层调用系统调用的次数, 提高C语言的IO函数的效率**
## 3.stderr  
**先来看下面的现象**
![[Pasted image 20251130105308.png]]
* stdout 和 stderr 默认都指向同一个显示器文件

![[Pasted image 20251130105349.png]]
* 再使用重定向符号`>`时, stdout成功发生重定向, 但是stderr没有重定向

这其实和重定向的写法有关, 我们平常写的 > 重定向其实是一种简化的写法, 
`./demo1 1 > log.txt` : 把fd = 1的下标中的内容修改为log.txt的指向
![[Pasted image 20251130105542.png]]
* 所以, > 这种写法是默认 是 更改的1的指向  叫做**标准输出重定向**

常见组合
**标准输出和标准错误分开存储**
```bash
./demo1 1> right.txt 2> err.txt
```
![[Pasted image 20251130110550.png]]
**标准输出和标准错误一起存储**
```bash
./demo1 1>all.txt 2>&1 all.txt
```
* & 将fd= 2指向stdout当前指向的位置*
![[Pasted image 20251130110758.png]]

>printf默认是向 fd(1)输出, perror默认是向fd(2)输出
![[Pasted image 20251130111117.png]]


为什么要存在呢 : 为了区分错误消息和正确消息

0, 1是为了方便用户随时都可以进行数据的输入和输出

**看一个错误**
![[Pasted image 20251130110126.png]]
为什么这里没有将 stderr 中的内容输出到log文件之中呢? 因为出现一个语法错误
`2 > log.txt` : 2和>中间有空格, 而我们知道, bash在解析命令行时 ,前面的是要执行的程序, 后面是命令行参数表, 在分割的时候是按照空格分割的, 所以2会被当做一个单独的参数存入 argv中, 实际上要传递的参数是 `2>
![[Pasted image 20251130110405.png]]`
**为什么要有stderr**
