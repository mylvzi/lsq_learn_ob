# 1.见识一下
新建一个可执行程序
![[Pasted image 20251203150302.png]]
* 展示了一个可执行程序所依赖的动态库文件
**ldd : print shared object dependencies**     : 打印依赖的动态库文件
![[Pasted image 20251203150345.png]]


windows : .dll(dynamic link library)  动态库文件 .lib静态库文件
linux : .so(shared objects)动态库文件  .a(archive) 静态库文件

# 2.具体讲解

## 静态库
> 静态库最大的特点就是在编译形成可执行程序时, 会将.o文件中的方法的具体实现加载到内存之中
* 所谓的**链接**, 本质上是将多个.o文件拼接到一起, 形成一个完整的可执行程序
![[Pasted image 20251203170201.png]]
* .o文件提供具体的实现, 头文件只是提供一个声明(告诉你怎么用, 参数是什么, 如何提供参数)
* .o文件已经是一个可以执行的机器代码

>接下来自定义一个静态库
![[Pasted image 20251203174032.png]]

> gcc进行最后的链接操作


![[Pasted image 20251203171549.png]]
* 找不到这个头文件  gcc默认从 /usr/include 找头文件
* -I 指定头文件路径
![[Pasted image 20251203171650.png]]
* 找不到myadd 的实现, gcc默认从 /usr/lib中找方法的具体实现
* -L : 指定自定义库文件
![[Pasted image 20251203171829.png]]
* 还是找不到?要指定需要链接的库, 引文一个库文件中可能有多个库
* -lxxx : 指定要链接的库

```bash
gcc main.c -I ./mylib/include -L ./mylib/lib -lmyc
```
* 这里面有一个最大的坑!就是 **main.c 必须在使用的静态库前面!**, 否则无法编译
* ld是从左到右处理目标文件和静态库的

链接器在在链接的时候需要知道**哪些东西需要进行链接**, 如何确定呢?是去扫描**未被解析的符号**
如果先扫描到myc这个库文件, 发现其中没有任何未解析的符号, 就不会从这个库文件中提取myadd.o
如果先扫描到main.o, 发现**myadd**这个符号是一个未解析的引用, 就会从后面需要链接的库中找到这个引用的具体实现
* 库文件是什么 : 就是对多个.o文件使用ar工具进行打包
* 为什么要有库文件 : 提高开发效率

在链接的时候需要知道头文件和头文件中需要进行引用的方法的机器码文件

gcc默认使用的是动态库文件
## 动态库
>动态库是在开发过程中经常使用到的一种链接操作, 不需要像静态库链接一样使用ar工具专门打包为静态库, 直接使用gcc即可

```bash
gcc -fPIC -c myadd.c  # 编译myadd.c文件  形成一个机器码指令  fPIC 位置无关代码
gcc -shared -o libmyc.so myadd.o # 创建动态库文件并引入库文件
```
* fPIC : 编译时形成**位置无关代码**, 让生成的机械指令不依赖固定的内存地址, 能被加载到任意地址运行

![[Pasted image 20251203201713.png]]
编译期间可以通过,但是运行的时候保错 --> 找不到对应的动态库文件

编译时能通过, 只是告诉gcc/g++这个编译器动态库文件在哪里, 后面的运行是靠操作系统的
OS在运行对应的程序时, 需要将可执行程序对应的文件和依赖的动态库文件都加载到内存之中
所以, OS也需要知道动态库的位置. Linux会有一个默认的搜索路径
```bash
/lib
/lib64
/usr/lib
/usr/lib64

```

1. 直接将动态库拷贝过去
2. 创建软链接  只提供一个快捷方式
3. 环境变量  动态库的搜索路径  环境变量这个东西是内存级的, 关掉之后就会消失了 LD_LIBRARY_PATH
4. 修改 .bashrc配置文件会有一个配置文件   在配置文件中添加环境变量的值
需要帮助OS找到依赖的动态库文件


默认使用的是动态库, 没有动态库就去找静态库文件
-static的意义是什么
必须强制的进行静态链接, 就必须要求所有依赖的文件都需要对应的静态库文件依赖

# 附加问题 : 动态库的加载 -- 可执行程序和地址空间
![[Pasted image 20251204092634.png]]
**动态库的加载过程 :**
1. 创建进程中内核相关的数据结构, 将可执行程序由磁盘加载到内存之中, 并通过页表建立虚拟地址和内存中实际物理地址之间的映射关系
2. 进程运行过程中, 发现需要用到某个动态库, 根据程序内部提供的地址, 将动态库加载到内存之中, 操作系统会创建一个**数据结构**管理加载到内存之中的库文件
3. 库文件会有一个**起始地址**, 在正文代码中会进行存储, 库中公共的方法会通过**起始地址 + 偏移量**的方式映射到堆栈之间的**共享区**
4. 如果要使用这个方法, 会根据共享区中的虚拟地址通过MMU转换为实际的内存物理地址, 执行相应的方法
5. 在运行的过程中, 首先会发现要使用的动态库的地址没有被加载到内存上, OS会识别到这个错误(缺页中断)
为什么说动态库形成的过程中要使用`-fpic`表示位置无关编码呢?这里的位置无关指的是库文件加载到正文代码区哪里是无所谓的, 公共的方法都是通过**起始地址 + 偏移量**来进行虚拟地址的存储的
```c
struct link_map {
    ElfW(Addr) l_addr;      // 该库加载到内存后的基址(base address)
    char *l_name;           // 库文件路径，例如："/lib/x86_64-linux-gnu/libc.so.6"
    ElfW(Dyn) *l_ld;        // 指向 .dynamic 段，用于解析符号/重定位
    struct link_map *l_next; // 双向链表 next
    struct link_map *l_prev; // 双向链表 prev
};
```

> 编译成功的可执行程序, 没有被加载到内存中运行, 二进制代码中已经有地址了!
> 这个地址不是磁盘的物理地址(LBA扇区号), 就是之后需要在进程地址空间中的虚拟地址!
> 一旦程序被加载到内存中运行, 每一行代码都有自己的**物理内存地址**, 物理内存地址和虚拟地址之间通过**页表**进行映射

1. mm_struct中的code_start, code_end这些属性的值是怎么被赋值的呢?从编译好的二进制代码中获取
2. 在Linux中, 所有通过c程序编译好的文件, 都要遵循**ELF格式(Executable and Linkable Format)**,[[ELF详解]], 在运行的时候, 会先寻找main函数的地址, main函数的地址就是入口地址
3. 虚拟地址这个概念, 不仅仅是操作系统本身有, 编译器, 加载器都要有对应的实现


>从底层理解程序是如何一步一步被执行的

1. 找到main函数的地址, 这是程序执行时的起始地址
2. CPU中的PC指针(程序计数器)存储**下一条要执行指令的地址(虚拟地址**
3. 地址解析 : MMU(内存管理单元)读取当前进程的CR3(CPU上的控制寄存器, 存储当前进程页表的基地址 -- 找到页表), 根据PC中的虚拟地址, 找到对应的物理地址
