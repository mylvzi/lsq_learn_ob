# ls

*什么是文件*
> 文件 = 文件属性(本质上也是一个数据) +文件内容
> 文件的操作:属性操作 +内容操作
> ls 的本质是展示文件的属性

* ls -l:显示文件的详细信息  long format
* ls -la:显示所有文件(包括隐藏文件 a : all) 以.开头的文件是隐藏文件
* ls -ld:只查看目录本身    directory
* ls * :删除所有内容    可以添加通配符



> 任何目录下,都默认具有两个隐藏目录  .(当前路径) 和 ..(上级路径)  包括根目录
> ![[Pasted image 20250923112701.png]]
> `/` :根目录
> `..`:回退到上一级目录/回退到父节点  表示上一级目录
> `.`:表示当前目录 ,方便找到当前目录下的文件  比如执行当前目录下的可执行文件  ./a.out
> 方便用户定位当前路径和进行回退操作
# pwd
显示当前路径
/ 是Linux中的路径分隔符

为什么要有路径 : 计算机中存储文件需要被特定标识


# cd
cd -  :进入到最近一次所处的目录  切换到上一次访问的目录
cd ~ : 进入用户家目录  进入到当前用户所处目录   不同用户的家目录位置不同, root : /root    lsq : /home/lsq,  第一次登录时,默认都是进入到当前用户的家目录

root用户:属于超级用户目录,也可以创建其他普通用户进行登录

云服务器上是一个裁剪版的linux服务器,如果使用vmvare等具有桌面化的服务器,是有和windows一样的desktop和downloads文件夹 的 

> 多用户操作系统: -- windows和Linux都有  
> 桌面本质上是一个文件夹:
> 	1.使用用户登录
> 	2,访问登录用户的桌面文件夹
> 	3.将桌面文件夹的内容在桌面上以图形化界面进行展示
> 	包括下载目录也是




# whoami
查看当前登录用户账号


# adduser
创建一个新的普通用户

# which
> 找到本地服务上 可执行程序的 位置
> 什么是可执行程序呢?就是可以直接运行的程序,像基本的命令本质上就是可执行程序
> which的作用就是找到路径
![[Pasted image 20251004153949.png]]


在Linux安装一个小程序 sl  打印一个跑动的火车
![[Pasted image 20251004154025.png]]
直接输入sl就可以运行


>本质 : `which` 就是在`$PATH` 环境变量规定的目录中,顺序查找要执行的命令,看他对应的可执行文件在哪里
>明白一点 : ls -l 等价于  /usr/bin/ls -l

> $PATH : 环境变量 专门存储系统在运行过程中可能需要的可执行程序命令
> root@iv-ye36a78irk5i3z57m5br:/usr/games# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

上面还说到,which只会在 $PATH中查找 ,下面验证下
```shell
echo $PATH
		/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
which sl
	/usr/games/sl

```

/usr/games 这个目录被设置为环境变量,所以能够找到,接下来自定义一个脚本,看看能否找到
# touch
创建普通文件

# stat
stat xxx   : 查看文件的详细属性

# mkdir
创建目录  默认是创建一个空目录

mkdir -p  递归创建父目录
# tree
以树形结构展示指定目录的结构

# rmdir
 只能删除空目录

# rm
删除文件/目录

rm -f :强制删除
rm -r:删除目录  递归进行删除  即使是空的,也要递归删除
rm -rf:强制递归删除
rm -rf data*1   表示通配符,匹配任意字符

> rm 删除就是删除  不像windows一样丢到垃圾桶里
> 不小心删除了,如实汇报就可以;
> 有不确定的删除文件/目录,先进行备份!!

# man
man 指令 : 显示指令相应的内容

man man
man中其实有多个手册
![[Pasted image 20250928111340.png]]
* 1.查看命令手册
* 2:查看Linux系统调用
* 3 : 查c库函数

man 1 ls : 在1手册里面进行搜索
man : 默认是第一个手册,会从上往下找


# cp
复制粘贴
cp src dst  拷贝文件/目录
* dst:  目录 / 带路径的文件

cp -rf src dst : 拷贝目录

# mv
重命名 : mv src dst  也可以进行文件的备份  mv f.txt t.backup
移动目录  带路径就是进行剪切的功能
mv src path/新名称

# cat
打印文本内容
cat -n : 打印出对应的行号
cat -s : 忽略多余的空行
tac : 逆向打印文本内容

> cat: 本质上是从文件中读取数据,然后将读取到的数据输出到**显示器文件**  本质上是执行**读权限**
> 默认情况下其实是从**键盘文件读取数据,然后输出到显示器文件**  所以只输入一个 cat  会一直尝试从键盘中读取数据并进行打印
> cat log.txt : 从其他文件中读取数据,然后输出到显示器文件上
> ![[Pasted image 20250929113534.png]]
![[Pasted image 20250929113802.png]]

# echo
> echo: 本质上是向**显示器文件输出内容**  本质上是执行 **写权限**
> ![[Pasted image 20250929113320.png]]

那么我们可以通过**重定向的方式,更改echo命令输出的位置**,比如重定向到一个普通文件

> '>' :输出重定向:  等价于c语言中  以 w 方式打开文件并写入
> 	1. 创建一个空文件
> 	2. 清空文件内容
> ![[Pasted image 20250929114007.png]]

`>log.txt` : 输出的内容为空, 直接清空文件的内容
* 文件存在 : 打开并清空, 然后写入输入
* 文件不存在:直接创建新文件,然后写入

![[Pasted image 20250929115221.png]]




> '>>' : 写入文件,不会清空原有的文件内容     追加重定向 
> 等价于c语言中的 以 a 方式打开文件并写入
![[Pasted image 20250929115832.png]]




# 查看大文本 -- 查看文件的内容
> more: 打满一屏输出,按下enter键下翻查看,只能向下,不推荐
> less: 和more类似, 可以通过上下键 进行翻阅   推荐使用   / 可以搜索关键字       q 退出查看    less也可以逐行查看
> head:  head -n  查看文件前n行文件
> tail : tail -n 查看文件倒数n行文件
> 查看中间几行?
# more
可以打满一屏输出,按下enter键可以下翻查看,但是只能向下

# less
> 和more很像,但是可以通过上下键切换,相较于more更加方便

# wc
> wc(word count)
> wc -l : 统计有多少行

**如何查看中间几行数据**
> head -10 log.txt | tail -5
> tail -50 log.txt | less  : 逐行查看后50行数据
# 时间相关命令
> date: 显示时间
> 格式化输出:date +%Y-%m-%d_%H:%M:%S
> date +%s : 显示时间戳
> cal: 显示日历
> cal -3 : 查看左右两个月日历
> cal 1999 : 查看1999年日历



# find  非常重要的一个命令
> 查找文件 : find path -name 文件名  在指定文件中查看文件   文件也可以是通配符匹配



Linux文件目录
![[Pasted image 20250929164422.png]]


# grep
> 行文本过滤工具 : 根据关键字匹配包含关键字的行
> grep -n : 显示行号
> grep -v : 留下不包含关键字的行   一种逆向选择 
> grep -i : 忽略大小写   正常匹配时必须是完全匹配




# zip/unzip 打包和压缩
> 背景: 什么是打包和压缩,
> 为什么要打包和压缩:
> 1. 缩小体积,占用磁盘资源少,下载速度更快   用户体验更好
> 2. 不会轻易丢失文件

**zip**
> zip file.zip file : 打包文件
> zip -r dir.zip dir : 打包目录
> zip -r test.zip * : 将当前目录下所有文件都进行打包
> 打包几个文件,就在后面跟几个文件就行

**unzip**
> 解压文件  默认是解压到当前目录
> unzip dir.zip -d /path   解压到指定路径下
# tar
> tar -czf file.tgz f1 f2 : 创建,压缩为.tgz的压缩包文件
> tar -xzf file.tgz
> tar -xzf file,tgz -C /home   解压缩到指定路径下  这里的c必须是大写的

**总结**
>压缩,解压缩文件的后缀取决于 使用的压缩算法,最常见的就是zip文件和tar.gz(tgz)文件
>打包压缩最大的用处就是在网络中进行数据的传输   一是体积小,传输速度快,二是不易丢失


# scp
> scp(secure copy) : 安全拷贝, 符合ssh协议,支持远程主机之间传输,完成文件的拷贝工作
> src user@ipaddress:/path/to/copy dest

比如, 我现在想Linux服务器传输数据到本地windows
```shell
scp root@115.190.47.29:/root/test2.tgz C:\Users\绿字\Desktop\找工作
```

**补充知识**
1. 一个服务器是有两个ip地址的,一个是内网IP,一个公网IP;内网IP是指在当前局域网下的IP地址,公网IP是你在整个互联网中的地址,是全球唯一的; 本机访问外网IP,是需要通过NAT机制将内网IP转换为公网IP,公网IP之间在进行数据传输

查看公网IP:
```shell
curl ifconfig.me
```
![[Pasted image 20250929212306.png]]
查看内网IP:
```shell
hostname -I
```
![[Pasted image 20250929212317.png]]
# bc
> Linux上的计算器 
> echo 1+2 | bc   : 3   



# uname
>查看体系结构
>cpu架构 和
>uname -r : 所使用的内核版本  前缀是Linux的内核版本  
>cat /proc/cpuinfo : 打印当前服务器cpu相关信息
>cat /proc/meminfo : 打印当前服务器内存相关信息clear
>

# 热键
>tab : 自动补全  提高速度
>ctrl +r : 根据历史命令进行搜索,按下tab键直接补全完整命令
>reboot : 进行重启
>shutdown : 关机  云服务器一般不建议关机


指令命令全部结束!!!!!






**重新认识指令**
>  指令本质都是程序    指令就是已经存储在 usr/bin 目录下的二进制文件   , 而程序本质上也是**文件**,文件 = 文件属性 + 文件内容
>  =============
>  which ls :  找到ls命令在系统中所处的位置   
>  alias : 给命令起别名   alias也是一个Linux命令     ll == ls -l            alias lisi='ls -l -a'
>  
>  系统执行指令时,需要去查找指令所在位置   which tree


**认识 | 管道**
>    | : 管道  进行资源传输的  在信息网络中,传输的资源是 **数据**
>    入口  出口  数据传输



# Linux中一切皆文件
> 包括各种硬件设备(键盘,显示器,磁盘等等),甚至还包括终端
> echo : 打印到对应终端文件的显示器文件上

![[Pasted image 20250929121324.png]]

* tty(TeleTypeWriter):电传打印机,也指终端设备:输入tty就可以显示当前终端所的文件路径


```shell
#! /bin/base
for i in {1..1000}; do echo "hello linux"; done > log.txt
```



# 补充
> shell 命令 以及运行原理

* **大部分**指令本质上就是文件 是存储在磁盘中的系统文件夹下
* 用户执行某种功能时,不是直接让操作系统执行对应的指令,而是先交给**外壳程序**  用户接口

![[Pasted image 20250930084816.png]]

什么是外壳程序,就是套在操作系统内核外面的方便管理操作系统内核的程序
外壳程序也被称之为**shell 程序**,shell有两种方式,图形化界面(windows)和命令行(Linux)
你想想开机的时候总是最后加载外壳程序,windows是最后显示图形化界面,Linux是最后显示命令行,之前就是一直在加载操作系统的内核

为什么要有外壳程序:
1. 是什么 : 介于用户和操作系统之间的软件,是一个**命令行解释器**,将用户的命令翻译给kernel处理,将kernel命令翻译给用户
2. 为什么 : 方便用户和操作系统交互, 用户很难直接与操作系统内核交互; 对用户的请求进行 **合法化检测**,从而保护操作系统
3. 怎么办 : 真正的bash只需要等待就可以, 负责核心业务; 每次执行命令bash都会创建一个**子进程**,让这个子进程去执行命令, 不影响整个shell外壳程序

shell : 媒婆  所有外壳程序的统称
bash : 王婆  是一种shell程序的具体实例

