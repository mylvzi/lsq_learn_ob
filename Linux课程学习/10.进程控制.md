> 进程创建
> 进程终止
> 进程等待
# 进程创建
**进程 = 内核相关的管理数据结构  + 代码和数据**
* 内核相关的管理数据结构 = task_struct(进程控制块) + mm_struct(进程地址空间) + 页表(映射)

如何理解进程具有独立性呢?子进程有自己的管理数据结构, 子进程会继承父进程的代码和数据
这里的独立性是指"当尝试对共享变量修改时, 就会触发写时拷贝, 重新开辟一块独立的内存"

**创建进程的方式**
1. fork()创建子进程
2. ./执行进程, 父进程默认是bash

**fork()函数的返回值**
* 父进程 : 返回创建的子进程pid  方便父进程对子进程进行管理
* 子进程 : 0

**fork()的用法**
或者说创建子进程的原因,一般有以下两种作用
1. 让子进程去执行来自父进程的任务
2. 让子进程去执行一个新的程序, 比如在子进程中去执行其他程序
**fork()失败的原因**
系统资源已经达到瓶颈, 无法继续创建子进程
此时, 父进程返回-1表示创建子进程失败

# 进程的终止
## 1.终止是在干什么
> 进程创建的相反操作 -- 释放内核相关的管理数据结构 + 代码和数据

会先释放代码和数据, 内核相关的管理数据结构后释放
## 2.进程终止的三种情况
**main函数的返回值理解**
![[Pasted image 20251120115504.png]]
?是bash中一个Special Parameters, 可以暂时理解为**bash进程收到的最近一次子进程的退出码**
[[Special Parameters详解]]

由此可以看出, 父进程需要知道子进程的执行情况, 如何知道呢?肯定是通过接受子进程的退出码!
失败要有失败的原因  错误码 错误码描述  和http状态码一样
C语言中有一个函数**strerror**, 专门用于打印错误码对应的信息
![[Pasted image 20251120121246.png]]

**进程终止的三种情况**
1. 代码跑完,结果正确
2. 代码跑完,结果不正确     正确与否, 可以通过退出码决定 
3. 代码执行时, 出现了异常,提前退出(代码没跑完)

退出0表示退出成功, !0表示退出失败
![[Pasted image 20251120121627.png]]

一旦出现异常, 退出吗就没有意义了,因为代码并没有执行完毕, 此时只关心出现异常的原因;
出现异常的本质 - 进程收到了来自OS的终止信号,下面以野指针为例
![[Pasted image 20251120122833.png]]
* 异常就是OS向进程发送终止信号
* 退出码 = 128 + 信号值


**判断进程以哪种方式结束**
1. 先确认是否是异常, 如果是异常, 代码没有跑完  根据退出信号可以判断是什么异常
2. 不是异常, 根据退出码判断运行结果是否正确


**衡量一个进程退出状态, 只需要关注两个数字 : 退出码和退出信号**

会将退出码和退出结果存储到子进程的属性中pcb, 等待父进程进行读取相关的信息 
退出码 : exit_code  判断运行结果是否正确(非异常)
退出信号 : exit_signal  判断是否是异常
![[Pasted image 20251120123145.png]]

## 3.如何终止
1. main函数return表示进程终止(非main函数, return表示函数结束)
2. 代码调用exit函数  参数等同于return的值   exit(1) ~ return 1 
3. 代码调用_exit函数

exit和return的区别   exit 在代码的任意位置调用, 都表示进程退出

exit和_exit的区别    exit会帮助我们进行刷盘的操作,冲刷缓冲区  而_exit不会
从位置上来说, exit是C语言库函数, 属于用户接口, 而_exit属于systemcall
由此也可以得出, 缓冲区的位置肯定不在操作系统内部, 也不再系统调用层 肯定不是内核缓冲区
![[Pasted image 20251120141843.png]]
![[Pasted image 20251120141936.png]]
![[Pasted image 20251128103945.png]]这是对exit函数的描述, 所有的标准输入输出流都会被刷入和关闭, 而这个stdio是在进程启动时默认打开的三个文件, 是对fd的封装, 这三个流都有**缓冲区(用户级的缓冲区)**, flush就是在底层调用write系统调用, 将存储在用户级缓冲区的中数据先拷贝到Page Cache(内核级缓冲区)中, 在写入到磁盘中
# 进程等待
>结论 : 任何子进程, 在退出的情况下, 一般必须要被父进程进行等待.
>父进程不管不顾, 子进程变为 Z状态(僵尸进程)  内存泄漏


为什么要进行进程等待?
1. 解决子进程僵尸状态, 回收系统资源, 避免内存泄漏  一定要考虑的
2. 父进程需要获取子进程的退出信息(退出码和退出信号)  可选功能

## 怎么办(如何进行进程等待)
>要实现进程等待, 其实就是让父进程在子进程执行完毕之后, 获取到子进程的退出码 + 退出信号
>主要通过两个函数实现 : 
>wait
>waitpid


**wait**  等待父进程中任意一个子进程退出
```c
pid_t wait(int *wstatus)
```
* 返回值 :状态发生变化的子进程pid  失败返回-1

等待成功时, 返回子进程pid
子进程不退出, 一直在执行, 那么父进程就会**阻塞等待**
scanf为什么会让进程处于S状态呢?因为进程需要等待键盘资源就绪, 本质是将进程的pcb连入到键盘结构体的等待队列中
父进程wait子进程, 本质上是把父进程连入到子进程的等待队列之中, 子进程执行完毕, 就会唤醒父进程, 让父进程读取子进程pcb中的结束信息 , 可以理解为父进程在等待子进程这个软件


**waitpid**
```c
pid_t waitpid(pid_t pid, int *wstatus, int options);
```
`pid` : 
* -1 表示等待所有的子进程
* 0 : 等待同一进程组下状态发生改变的子进程
`options` : 默认情况下, waitpid是只会等待**子进程变为终止状态这种状态变换的子进程**,但是可以通过传入不同的options来更改等待规则
wstatus  是一个输出型参数, 会将子进程的**退出码 + 退出信号**输出到wstatus参数对应的内存之中
而子进程的退出码是通过exit函数进行传递的
![[Pasted image 20251120145701.png]]
输出型参数  scanf
子进程的退出信息   status  的位图来分别存储**退出状态 和退出信号**
![[Pasted image 20251120150911.png]]
![[Pasted image 20251120142905.png]]
* wait和waitpid都是系统调用
* 作用都是:等待调用进程中的子进程的状态发生改变, 并获得状态发生改变的子进程的相关信息
* 状态改变有三种情况 : 子进程终止(R/S->Z)  子进程被信号停止(->T)  子进程因信号重新执行

**进程等待的分类**
> 阻塞等待 : 如果子进程没有退出, waitpid就会一直等待, 父进程一直在进行阻塞等待 , 被连入到子进程的等待队列中, 无法执行其他操作
> 非阻塞等待 : 父进程通过waipid发现子进程仍然在运行, 父进程此时可以做其他事情

对于waitpid()函数, 返回值有三种情况
1. >0 : 子进程执行完毕, 返回子进程的pid
2. =0 : 设置了WNOHANG, 此时子进程没有结束仍在运行  子进程的状态没有发生变化
3. -1 出现错误

![[Pasted image 20251120203349.png]]

waitpid(pid_t pid, int* wstatus, int options);默认情况下是**阻塞等待**
如果将options设置为内置的一个宏**WNOHANG**,此时waitpid函数就是**非阻塞等待**
其他宏 :
* `WNOHANAG` : return immediately if no child has exited  
* `WIFEXITED(status)` : 如果子进程正常终止, 此宏的值就是true  判断子进程是否正常终止
* WEXITSTATUS(status) : 如果WIFEXITED为true, 此函数返回exit_code
* WIFSIGNALED(status) : 判断子进程是否因信号导致终止
* WTERMSIG(status) : 如果WIFSIGNALED为true, 此宏返回exit_sig


![[Pasted image 20251120204947.png]]


# 进程程序替换
## 1.代码、现象
![[Pasted image 20251121102703.png]]
* 在自己写的程序里面执行了**ls**进程， 通过execl函数
* execl函数下方的printf没有被执行
## 2.原理
>上述过程其实是发生了**进程的程序替换**, 就是在一个进程内部去执行另一个进程的程序
>进程 = 内核管理数据结构 + 代码和数据
>进程的程序替换 - 替换的是代码和数据  但是(内核管理数据结构)pcb 地址空间 页表都没有新的创建
![[Pasted image 20251121103041.png]]
* 站在进程的角度, 进程的程序替换就是将需要执行的进程的代码和数据覆盖原有的代码和数据(解释了为什么execl下方的printf函数不会被执行)
* 没有创建新的进程(没有新的内核数据结构创建)

**补充**
要执行的程序都是存储在磁盘之中的,如果想要执行程序, 就必须将在磁盘中的数据加载到物理内存之中
为什么 ：冯诺依曼体系结构规定, CPU只能加载离其较近的存储结构**内存**
怎么加载到内存？exec系列的函数， 就是类似于Linux上的加载函数  , 本质上就是将硬件资源拷贝到内存之中， 这个操作肯定是操作系统做的，所以exec系列的函数一定是系统调用或者底层使用的是系统调用
## 3.将代码更改为多进程版本
fork（）创建子进程， 让子进程去执行要执行的程序， 父进程去等待子进程执行完毕即可
让子进程去执行一个新的程序
```c
  6 int main()
  7 {
  8     pid_t cid = fork();
  9     if(cid == 0)
 10     {
 11         // child
 12         execl("/usr/bin/ls", "ls", "-a", "-l", NULL);
 13         exit(132);                                                                                                   
 14     }
 15     
 16     // father
 17     sleep(1);
 18     int status = 0;
 19     pid_t id = waitpid(cid, &status, 0);
 20     if(id > 0)
 21     {
 22         // 子进程退出
 23         printf("child is exit, pid = %d, exit_code = %d\n", id, WEXITSTATUS(status));
 24     }
 28 }
```
![[Pasted image 20251121104014.png]]

execl函数也有可能执行失败, 如果执行失败, 相当于将要执行的进程的代码和数据加载到内存失败, 也就是原有的代码和数据没有被覆盖, execl下面的代码就会继续被执行
```c
execl("/usr/bin/lsssss", "lssss", NULL); // 传递一个错误的参数
```
![[Pasted image 20251121104434.png]]

**总结**
> 创建子进程，让子进程完成任务, 一般分为两种:
> 1. 子进程完成父进程要执行任务的一部分, 此时代码和数据都是共享的, 如果要对共享变量进行修改, 就会触发**写时拷贝**, 在内存中新开辟一块空间, 存储要修的变量
> 2. 子进程新执行一个程序, 代码和数据都是新的, 如果直接覆盖, 相当于子进程对代码和数据都要进行修改, 为了保证进程的独立性, 代码和数据都会发生写时拷贝

![[Pasted image 20251121105030.png]]

**让子进程去执行另一个进程(C++)**
![[Pasted image 20251121110702.png]]
## 4.使用所有替换方法，认识函数参数含义

`execl`
```c
int execl(const char *pathname, const char *arg, ...);
execl("/usr/bin/ls", "ls", "-a", "-l", NULL);
```
* pathname : 要执行的程序的路径
* const char* arg : 提供的参数  在命令行参数中怎么写， 参数就怎么写
* 这里的**l**表示列表， 即可以提供多个参数作为参数列表
![[Pasted image 20251121122632.png]]
* 第一个参数必须要指向需要执行的进程的文件名
* 后面的参数是一个字符串列表， 可以一个或者多个，但是必须以NULL结尾
* 作为对比， v相关的函数被当做一个**数组**
* arg其实就是bash进程维护的那个命令行参数表， 是一个二级指针； 只不过在有bash的情况下， 会自动把参数传递给子进程， execl函数只是需要手动传递参数

`execv`
```c
     int execv(const char *pathname, char *const argv[])
     
     char *const argv[] = {
	     "ls",
	     "-l",
	     "-a",
	     "NULL"
     };
     execv(“/usr/bin/ls", argv);
     
```


`execvp`
```c
int execvp(const char *file, char *const argv[]);
execvp("ls", argv);
```
* p : PATH, 表示此系列的函数都会从环境变量PATH中查找要执行的程序

char** environ  bash进程的系统环境变量     第三个参数就是环境变量， 可以自己去自定义环境变量  相当于给子进程传递环境变量

`execvpe`
```c
int execvpe(const char *file, char *const argv[],
                       char *const envp[]);
```


![[Pasted image 20251121140152.png]]
* 带e的exec（execle， exevpe）允许你自己制定新程序的环境变量
* 不带e的exec（execl，execv）会自动当前进程的环境变量
execvpe的第三个参数 **envp**就是环境变量参数, 和bash进程维护的环境变量表是相同的, 都是二级指针

带e的exec
![[Pasted image 20251121141436.png]]
不带e的exec
![[Pasted image 20251121141142.png]]
**深入理解**
Linux手册中有这样一段描述
![[Pasted image 20251121122054.png]]
exec系列的函数, 本质上是用一个新的**进程映像**替换原有的进程映像

EXEC(3) 但部分都是
底层都是[[execve函数]]这个系统调用,其他的都是此函数的封装接口
主要是为了适应不同的场景
## 5.自主shell编写


细节补充

1.无法切换路径  cd 命令失效
![[Pasted image 20251124162959.png]]

cd命令的核心是**chdir()**, 即切换当前工作目录, 本质上修改了task_struct中的工作目录,PWD只是一个提示性变量,告诉shell脚本使用,知道当前实在哪一个目录下
![[Pasted image 20251124165713.png]]

>       The current working directory is the starting point for interpreting relative pathnames (those not starting with '/').
		A child process created via fork(2) inherits its parent's current working directory.  The current working directory is left unchanged by execve(2).

* 当前工作目录是解释相对路径的起点
* 通过fork()创建的子进程会继承父进程的工作目录
* 使用execve执行新程序,工作目录不会发生改变(execv本质上时发生了进程替换, 进程替换并不会创建新的进程, 仅仅替换代码段和数据段, 而工作目录这个属性属于task_struct中的属性)

