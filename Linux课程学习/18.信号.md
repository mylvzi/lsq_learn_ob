# 一.信号的基本概念
>1.信号 : Linux提供的一种, 向指定进程发送特定事件的方式, 做识别和处理
>2. 信号的产生是异步的, 进程并不知道信号什么时候会来
>3. 进程收到信号, 并不会立即处理, 可能是等待一段建再去处理, 但是进程一定记得要去处理这个信号(会执行保存操作)

![[Pasted image 20251214140030.png]]
* 1-31 : 普通信号
* 32 - 64 : 实时信号
* 每一个信号其实都是一个**宏**

>理解发送信号和保存信号 : 信号肯定是进程相关的一个属性 -- task_struct -- 位图保存
>保存信号 : 使用位图来保存信号
>发送信号 : 修改指定进程pcb中的信号的指定位图, 0-->1




signal 对信号实现自定义捕捉  可以对多个信号进行捕捉操作


SIGINT : 进程中断  --ctrl +c 向当前进程发送进程终止的信号

理解发送信号和保存信号
## 信号的处理
>当进程收到信号之后, 无论是什么时间进行处理, 都要对接收到的信号进行处理,一般来说, 处理操作有三种方式
1. 默认动作
2. 忽略动作
3. 自定义处理 -- 信号的捕捉
**signal : 信号处理函数**
```c
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
```
* signum : 要处理的信号
* handler : 对signum执行的处理操作(上面的三种方式)  是一个返回值为void,参数为int的函数指针
![[Pasted image 20251214180531.png]]

![[Pasted image 20251214180621.png]]
1. SIG_IGN : 忽略信号
2. SIG_DFL : 信号的默认操作
3. 自定义捕获信号
4. SIGKILL(9)和SIGSTOP(19)不能被捕获或者忽略

关于自定义捕获信号, 手册中指出 : 如果信号的处理操作是**自定义处理**, 那么在调用自定义操作之前,系统会做出以下操作:
* 要么把该信号的处理方式重置为默认（SIG_DFL），老式处理方式
* 要么暂时阻塞该信号  现代的处理方式

然后再去调用你的处理函数, 这样做是为了避免**信号处理函数自己处理自己, 导致递归调用, 进而导致程序崩溃(栈溢出)**
![[Pasted image 20251214181545.png]]
连续按下两次ctrl + c, 运行的进程会暂时阻塞, 等待handler处理完, 再去处理第二次发送的信号!
![[Pasted image 20251214181446.png]]
![[Pasted image 20251214181606.png]]

>9和19信号无法被捕获

![[Pasted image 20251214181809.png]]
![[Pasted image 20251214181934.png]]

**为什么无法捕获呢?**
避免有用户恶意的捕获所有信号, 如果这样的话, 就会导致所有的信号都会去执行用户自定义的操作, 可能导致进程永远无法退出
# 信号的产生
1. kill -
2. 键盘输入 : ctrl + c(kill -2)  ctrl + /

>系统调用产生信号
kill - 向指定进程发送指定信号

```c
kill - send signal to a process
int kill(pid_t pid, int sig);
```

```cpp
// ./mykill 2 1234
int main(int argc, char* argv[])
{
    if(argc != 3)
    {
        std::cout << "Usage : " << "pid sig" << std::endl;
        return 1;
    }
    pid_t pid = std::stoi(argv[2]);
    int sig = std::stoi(argv[1]);
    kill(pid, sig);
    return 0;
}
```


![[Pasted image 20251214183405.png]]
![[Pasted image 20251214183621.png]]
* pid > 0 : 直接将sig发送给对应pid的进程
* pid = 0 : 发送给调用进程的进程组内部所有进程
* pid = -1 : 发送给调用进程有权限发送信号的所有进程(除了1)
* pid < -1 : 取绝对值
* sig = 0 ; 按理说没有信号0, 但是可以用于检查pid是否存在
raise  给调用进程发送信号(给自己发)
```c
NAME
       raise - send a signal to the caller

SYNOPSIS
       #include <signal.h>
       int raise(int sig); // 等价于 kill(getpid(), sig);
```
abort -- 6号信号   向调用进程发送
```c
void abort(void);
```

> 4.软件条件导致信号产生  由于某种机制导致的OS产生并发送信号

**管道rfd关闭, wfd一直写入**  OS会认为你这个操作是一个可能破坏硬件的操作:
![[Pasted image 20251206112216.png]]
**alarm  设定闹钟**
```c
alarm - set an alarm clock for delivery of a signal
unsigned int alarm(unsigned int seconds);
```
![[Pasted image 20251214215642.png]]
* 发送信号 **SIGALRM(14)**
* 如果秒数为0, 表示取消闹钟
![[Pasted image 20251214215742.png]]
* 返回上次闹钟的剩余时间
![[Pasted image 20251214220835.png]]


>5.异常产生信号

**FPE 除0异常**
![[Pasted image 20251214221237.png]]


**空指针引用异常**
![[Pasted image 20251214221604.png]]
* 程序为什么发生崩溃 : 产生非法访问, OS向进程发送信号
*  为什么OS会给进程发送信号呢 -- OS是软硬件资源的管理者, 如果出现异常, 比如溢出, 实际上是对硬件资源的非法操作,OS需要进行处理, 向目标进程发送信号


**/0报错的根本原因**
CPU中ALU(算数逻辑单元)实现除法指令时, 会首先做一个硬件检查:
```
if (divisor == 0) // Intel Cpu处理器
    raise_exception(DIVIDE_ERROR);
```

就会直接抛出异常, 不会进入到除法流水线之中
SIGFPE  （Floating Point Exception，实际包含 integer divide by zero）


不同的崩溃会产生不同的信号发送
所以说为什么刚才崩溃之后为什么一直死循环呢?一直调度,一直崩溃
![[Pasted image 20251214222235.png]]

> 崩溃为什么推荐终止进程 : 释放进程的上下文数据, 包括各种异常数据
> 异常本质上就是硬件发生错误, 硬件发生错误OS就要进行处理, OS就要向对应的进程发送信号


**那如何从底层理解空指针异常呢?**
MMU(页表翻译) + CR3(指向当前进程的页表, 基址寄存器)进行虚拟地址空间和实际物理地址的转换, MMU是CPU上的硬件资源, 负责虚拟地址和物理地址的转换, 不存在对应的映射关系, 触发Page Fault, 硬件出现错误 -- OS需要管理 -- 向进程发送信号

>Core和Term的区别

![[Pasted image 20251215103021.png]]
* Core和Term都是信号处理的操作, 都会执行终止进程的操作, 只不过Core会额外产生一个core dump文件(核心转储文件)
* Core 是Term的一种特殊情况,Core dump是**程序崩溃时内存的快照**,用于**保存案发现场**,用于后续调试

![[Pasted image 20251215104419.png]]
进程因异常退出, 除了有**exit_sig**,还有一个core dump标志位, 标记是否有core dump文件产生
![[Pasted image 20251215105636.png]]

> 几个术语

信号递达(Dlievery |handler) : 信号被处理
信号未决(Pending) : 进程收到信号,但是还没有处理的状态  信号挂起
信号阻塞(Block | mask) : 信号一旦产生, 就永远无法被递达, 除非手动解除阻塞

## Linux是如何管理信号集合的
![[Pasted image 20251215111255.png]]
**sigset**
>sigset = 一个记录“哪几个信号被包含的集合”，本质是一个按位存储信号的 bitmap

```c
typedef struct {
    unsigned long __val[_SIGSET_NWORDS];
} sigset_t;
```

>sigset是**父类**,在Linux信号集合中有多重角色

| sigset 用途                    | 含义                        |
| ---------------------------- | ------------------------- |
| **blocked set（阻塞集）**         | 当前线程屏蔽哪些信号                |
| **pending set（挂起集）**         | 哪些信号已产生但被延迟递送             |
| **saved mask**               | 调用 signal handler 之前的屏蔽状态 |
| **process-wide pending set** | 发送给整个进程但未被线程处理的信号         |
>sigset多个api操作, 提供了多个方法,让我们能更方便的操作位图

**设置集合**
```c
sigemptyset(&set);   // 清空  全部置0
sigfillset(&set);    // 全部置 1
sigaddset(&set, SIGUSR1);// 将set的SIGUSR1置为1
sigdelset(&set, SIGINT);// 将set的SIGINT置为0
sigismember(&set, SIGTERM);// 判断set中是否存在SIGTERM
```
**更改当前线程的阻塞信号(用户态)**
```c
sigprocmask, rt_sigprocmask - examine and change blocked signals
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```
* how : 标记位, 对当前线程的block_set执行什么操作
* set : 另一个set集合, 用于和set搭配
* oldset : 输出型参数, 保存老的set

**how标记位参数**
![[Pasted image 20251215112148.png]]

* SIG_BLOCK :当前进程的block_set和参数set做并集  添加屏蔽信号
* SIG_UNBLOCK : 取消屏蔽信号
* SIG_SETMASK : 将当前进程的block_set设置为和参数set一致

>底层执行链路

```css
SIGINT 产生
1. 内核收到信号 → 把信号对应位设到 pending set
    
2. 检查 blocked set（线程是否屏蔽？）
    
3. 如果被屏蔽 → 留在 pending  置为 1
    
4. 如果没屏蔽 → 将信号标记为“可递送”，安排 signal handler
    
5. handler 执行前，内核会保存当前 blocked set 作为“saved mask”
    
6. handler 执行过程中，blocked set 会临时被修改
    
7. handler 返回后，恢复 saved mask
```
* 在发送给handler处理之前, 会现将当前的block_set保存为saved_mask
* 执行过程中, block_set会被修改, 将**当前正在处理的信号给屏蔽**, 防止重入
* 执行完毕, 恢复源block_set

>被阻塞的信号产生时,会先保持在pending状态, 一旦取消阻塞, 就会进入handler
>阻塞和忽略是不同的,阻塞本质是block_set对应信号被置为1, 忽略是信号handler一种手段(三种手段)



**代码验证信号是否被屏蔽的状态**
>没有被屏蔽 : pending表全是0
>被屏蔽 : 向进程发送信号, pending表中对应位置为1

```c++
#include <iostream>

#include <unistd.h>

#include <cstdio>

#include <sys/types.h>

#include <sys/wait.h>

  

void PrintPending(sigset_t &pending)

{

    std::cout << "curr process[" << getpid() << "]pending: ";

    for (int signo = 31; signo >= 1; signo--)

    {

        if (sigismember(&pending, signo))

        {

            std::cout << 1;

        }

        else

        {

            std::cout << 0;

        }

    }

    std::cout << "\n";

}

int main()

{

    // 1.将2号信号屏蔽

    sigset_t block_set, oldset;

    sigemptyset(&block_set); // 清空原表

    sigemptyset(&oldset);

  

    sigaddset(&block_set, SIGINT); // 给block_set添加2信号

    sigprocmask(SIG_BLOCK, &block_set, &oldset); // 给当前进程的blockset添加2, 屏蔽信号2

  

    while(true)

    {

        // 2. 获取当前进程的pending信号集

        sigset_t pending;

        sigpending(&pending);

  

        // 3. 打印pending信号集

        PrintPending(pending);

  

        sleep(1);

    }

    return 0;

}
```


![[Pasted image 20251215125204.png]]

>信号的处理

**内核态和用户态的切换**
进程并不会立即处理信号,而是在**合适**的时机处理信号, 这个合适的时机, 就是**内核态切换到用户态**

>信号的捕捉

![[Pasted image 20251215125542.png]]
* 执行system call, 就会由用户态进入内核态, 只要出现异常, 就要进入到内核态
* handler有三种, DFL,IGN和自定义, 前两种不需要切换到用户态, 自定义的handler需要切换到用户态执行对应的handler, 执行完毕后,再进入到内核, 执行后续操作, 最后回到主流程
* OS不能直接转过去执行用户提供的handler方法, 即必须要切换到用户态  OS本身的权限比用户高得多, 如果直接切换, 等价于让用户以内核级别的权限执行用户的代码
![[Pasted image 20251215130208.png]]


>再谈地址空间 -- 访问OS和访问库函数没有区别

![[Pasted image 20251215130311.png]]
* OS是一个倍加再到内存中的**软件**, 进程地址空间的高地址, 存储的就是OS的虚拟地址, 通过**内核级页表**和实际在内存中存储的OS代码和数据一一映射
* 由于OS只有一份, 且所有进程都会访问OS, 所以内核级页表只用维护一份即可(动态库)
* OS本身就在进程的地址空间内部

>重新理解OS是如何知道键盘输入了什么


```css
键盘向cpu发送IRQ外设中断信号, cpu收到信号之后, 停止执行当前指令, 保存当前上下文, 根据idt(Interrupt Descriptor Table)找到键盘的中断处理函数地址(handler), 去执行对应的操作
```
* OS和外设的交互也是一种**信号机制**, 和外设的交互是纯硬件的
* 上面信号产生的五种方式, 都是纯软件的, 软件层面的信号交互, 就是借鉴的硬件交互

>理解system call 的调用过程
>系统调用的本质 : 用户想要访问一些**受保护的资源(文件/网络/进程管理)**, 自身无法直接访问, 需要请求内核代劳, 这就叫做系统调用

用户需要执行系统调用 -- 向CPU发送信号, CPU上的寄存器会保存中断信号 -- 根据中断号去内存中的**中断向量表**找到对应的函数指针 -- 去执行对应的systemcall

系统调用的函数指针被统一管理起来, 作为一个函数指针数组

![[Pasted image 20251216104950.png]]

>OS的本质就是一个**死循环** + 时钟中断 + 不断执行调度任务的

死循环, 是为了**对抗随机性**, 硬件中断随时都会来, 进程会随时阻塞(此时就要去执行其他进程)
```css
for(;;) {
    if(时钟中断到来) 检查是否需要调度
    if(当前进程时间片用完) 切换到别的进程
    if(当前进程在运行) 恢复该进程上下文，让它执行一点点
    （执行少量用户态指令）
}
```

>OS本身并不会让用户直接访问[3, 4]GB地址的空间范围, 因为OS不能让用户直接访问

**如何保护受保护的资源呢**
![[Pasted image 20251216105254.png]]
CPU上有一个CS寄存器(Code Segment), 告诉CPU当前执行的代码段是什么范围的
有一个标记为, 叫做**当前特权等级(CPL)**
* CPL = 0 : 内核态
* CPL = 3 : 用户态
从底层看内核态和用户态的切换就是 0-3之间的转换

>信号处理 -- sigaction

```c
sigaction, rt_sigaction - examine and change a signal action
#include <signal.h>
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```
* signum : 要处理的信号
* act : struct sigaction的结构体  输入型参数
* oldact :struct sigaction的结构体  输出型参数

```c
           struct sigaction {
               void     (*sa_handler)(int); // 函数指针  sighandler
               void     (*sa_sigaction)(int, siginfo_t *, void *);
               sigset_t   sa_mask; // saved_mask  保存旧的标志位
               int        sa_flags;
               void     (*sa_restorer)(void);
           };
```


![[Pasted image 20251216111128.png]]

>两个小细节
>sa_mask : 在执行handler之前, 会先保存原有的block_set, 在信号处理过程中, 会对正在处理的信号进行屏蔽(不可重入)

**验证信号正在被处理的时候, 信号会被屏蔽(Pending被置为1)!!!  不可重入**
![[Pasted image 20251216111748.png]]
![[Pasted image 20251216112635.png]]
对2号新号处理完成, 自动接触对2号新号屏蔽

>volatile关键字 : 主要是为了解决**内存可见性**和**指令重排序**
>内存可见性 : 告诉CPU, 不要做优化, 时钟从共享内存中读取数据, 保证一个进程修改的数据, 能够立即被其他进程看到
>指令重排序 : 对于创建对象这种操作, 可能还没有开辟好内存, 就直接返回地址了, 这本质上也是一种**指令重排序**

![[Pasted image 20251216133738.png]]

**以O2级别进行编译 -- 发送信号,却没有终止进程**
![[Pasted image 20251216133811.png]]
cpu做出了优化, 直接从CPU的寄存器中读取数据, 实际上在内存中的数字已经发生改变
![[Pasted image 20251216134027.png]]

编译器会有自己的优化级别   从编译的角度理解volatile挂念自的内存可见性


>子进程的退出 : 不是静悄悄退出的, 而是会给父进程发送**SIGCHLD**信号
>父进程会以轮训/阻塞的方式使用wait/waitpid不断地去扫描, 判断子进程是否退出
>如果退出, 及时的将子进程的资源释放

![[Pasted image 20251216134637.png]]



僵尸进程 :子进程退出, 但是父进程没有使用wait/waitpid去回收子进程, 就会编程zombie进程
 waitpid(WNOHANG) : 以非阻塞的方式等待子进程的退出
当前进程组内部会有很多子进程, 子进程的退出是随机的, 如果以阻塞的方式等待, 父进程无法去做其他事情, 以WNOHANG的方式等待, 会不断的扫描 判断是否有子进程退出, 这期间父进程可以去做其他事情
