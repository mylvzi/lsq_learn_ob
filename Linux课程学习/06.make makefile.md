>make是一个命令
>![[Pasted image 20251008152546.png]]
>makefile是一个文件
>make 会扫描当前目录下的 makefile文件, 完成编译/清理工作



![[Pasted image 20251008152439.png]]

`.PHONY:clean` : 无论是否有同名文件,都要执行clean命令
![[Pasted image 20251012100015.png]]
* src, bin : 都是变量名  后面是变量的内容  中间不能有空格
* $ : 表示取出内容   $(bin) ~ mytest
* $@ : 表示目标文件 等价于 mytest
* $^ : 表示依赖文件  等价于 demo1.c 依赖文件可以有多个
* make clean : 本身就是一个命令 用于执行文件清除
![[Pasted image 20251012102356.png]]

原文描述:
![[Pasted image 20251008154826.png]]
* 用于维护一组程序
* make 选项 目标

描述:
>The  make  utility  will  **determine automatically** which pieces of a large program need to be recompiled, and **issue the commands to recompile them**(自动决定一组大型程序中哪些部分需要被重新编译,并发出命令重新编译).  The
       manual describes the GNU implementation of make, which was written by Richard Stallman and Roland McGrath, and is currently maintained by  Paul  Smith.
       Our  examples  show  C  programs, since they are very common, but **you can use make with any programming language whose compiler can be run with a shell**(只要能被shell语言运行的编译器都可以使用make)
       command.  In fact, make is**not limited to programs**.  You can use it to describe any task where some files must be  updated  automatically  from  others
       whenever the others change.(只要存在 一些文件必须自动更新 在一些文件更新之后, 有这样的依赖关系)

![[Pasted image 20251008155638.png]]

1. 要使用make,必须要有一个makefile文件,这个文件中 使用特定的语法规则 描述 文件之间的关系(依赖关系)和 要执行的指令
2. 自动决定是否要重新编译的 判断操作 : 文件之间的依赖关系 和 修改时间  最后一行描述了判断依据 : 如果前置文件(被依赖的文件 prerequisiter files) 在 目标文件上一次修改之后 更新了,证明有变动  需要重新修改,就会触发编译  或者目标文件不存在(第一次编译)
3. 推荐使用 Makefile文件  因为在文件列表中处于更加靠前的位置

# 例子
>make 本质上 是一个 自动化工具, 只要存在 **某些文件需要再其他文件更新后自动完成更新**的依赖关系,就可以使用makefile
>最经典的场景当然就是程序的编译过程  demo.i -- demo.s -- demo.o

![[Pasted image 20251008160858.png]]
* 这个场景就属于 target 不存在, 当demo1.c文件更改后,自动更新mytest文件
上述指令写的其实有问题,在 Makefile中写的target是mytest,但是命令中写的是myexeByMake, 导致一直make,一直编译  为什么呢?因为比较的是mytest和 demo1.文件的修改时间,mytest一直没被创建,一直判断成功
![[Pasted image 20251008164055.png]]
重新编译的时机:
1. 依赖文件在目标文件上一次修改之后发生了变动
2. 目标文件为空

为什么这么设置呢:
1. 提高效率 : 对于一些大型程序而言, 编译一次需要的时间很长, 如果没有发生变动,就轻易不要编译;为了避免在没有发生修改,却仍然重新编译


注 : 
touch 依赖文件  会修改依赖文件的修改日期  重新make会触发重新编译
status file 查看文件修改时间

# 进度条小程序
## 预备知识
### 1.回车与换行
>`\n` : 在C语言中表示回车与换行,但我们要知道,回车和换行其实是两个不同的,独立的操作
>回车 : 直接回到当前行行首
>换行 : 直接向下平移一格(不移动到行首)
>\n : 先回车(回到当前行行首) -- 再换行(平移到下一行行首)
>\r : 回车  直接回到行首

### 2.缓冲区
>缓冲区就是一块内存, 要打印的内容会先存储到缓冲区中,再刷入显示器文件
>![[Pasted image 20251012104631.png]]
>* 遇到\n 就执行一次刷入 , 为什么是这种机制呢?首先缓冲区的存在是为了提高效率,如果直接一次性将缓冲区中的内容全部刷入 磁盘 ,会导致用户一次看到的内容太多, 用户体验不好  按行刷入比较 符合用户体验
>* fflush : 强制刷入

![[Pasted image 20251012104527.png]]
只有当程序结束时才会打印,因为内容会先存储到缓冲区中

**fflush**
![[Pasted image 20251012105652.png]]
* 会将用户空间内缓冲区中的所有输入强制写出到 实际的 显示器设备上

