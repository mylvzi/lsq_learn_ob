 ## 回顾文件


## 提炼一下对于文件的理解
打开文件本质上就是进程打开文件  进程是通过task_struct进行描述的, 那么task_struct中一定有一个
文件是在进程运行的时候才会被打开
属性和文件祥光
文件没有被打开 -- 存储在磁盘上
一个进程可以打开很多文件, 一个OS内部肯定会存在大量被打开的文件
OS一定要对这些文件进行管理 -- 先描述再组织

文件 = 属性 + 内容
![[Pasted image 20251124174858.png]]
当文件不存在, 会在**当前工作目录**创建文件, 那当前工作目录是哪里呢?肯定是执行文件打开操作的进程的cwd  所以文件的操作本质上还是进程的操作

w的方式打开文件:
1. 如果打开的文件不存在, 就会在当前工作目录创建一个新的文件
2. 每次打开, 都会先把原有文件内容清空

a的方式打开文件
1. 每次打开,直接在源文件的内容上进行追加

**echo aaa** : 会直接打印aaa  本质是将aaa 输出到 显示器文件
`echo aaa > 1.txt` : 在1.txt这个文件中写入数据  重定向输入到其他文件中
重新理解输出重定向  以w的方式打开要重定向到的文件, 然后将要输出的内容写入到文件中
`>` : 解释为以**w**的方式打开文件
`> 111.txt` : 创建111.txt文件(不存在就直接创建)
`> 111.txt` : 清空111文件中的内容


`>>` : 以a的方式打开文件, 会进行内容的追加


##  理解文件 
### 操作文件  本质是进程操作文件  进程和文件的关系

### 文件写入本质是向磁盘写入 -- 向硬件写入

>文件写入的过程 -- 用户通过用户操作接口,通过系统调用 ,委托操作系统向硬件资源中写入数据
>使用的C语言函数  本质都是对操作系统系统调用的封装  比如fopen/fwrite

**使用系统调用接口**
**open** : 打开/创建一个文件
![[Pasted image 20251126141306.png]]
`pathname` : 要打开的文件名称
`flags`  : 标记位, 文件打开时的状态
`mode` : 文件的权限(只有当flags中有 `O_CREATE`才有效)  
**flags**是一种位图形式的参数, 常见的flags有:
* 文件的访问模式(必选) : O_RDONLY只读  O_WRONLY只写  O_RDWR读写
* 可选标志 : O_CREATE(不存在就创建)  O_APPEND(追加写入)  O_TRUNC(写入前,先清空原有内容)

**mode** : 文件的权限, 
默认情况下会使用系统的umask值  umask也是一个系统调用, 可以动态的更新umask的值(在当前进程中的umask值)

**返回值**
![[Pasted image 20251126142741.png]]
* 打开成功 : 返回创建文件的fd
* 打开失败 : 返回-1

![[Pasted image 20251126142515.png]]
**标记位传参理解**
![[Pasted image 20251126122556.png]]
**write** : 向指定文件中写入大小不超过count字节的数据
![[Pasted image 20251126142655.png]]

**close** : 关闭文件

**打印文件的fd值**
![[Pasted image 20251126143731.png]]
疑问:
1. 为什么数字是连续的
2. 为什么从3开始?0,1,2去哪里了?

**对文件的理解**
![[Pasted image 20251126145102.png]]

> fd -- 内核中, 进程管理的文件与fd_array数组映射的下标, fd_array是一个指针数组, 数组的元素是指针, 指向进程需要管理的文件的内存地址
> 文件 = 属性(struct file) + 内容(内核级缓存)

站在操作系统的角度, open操作的本质
1. 创建struct file
2. 创建内核级文件缓存, 将数据载入(延后)  在合适的时候, 让OS将数据加载到内存之中
3. 查找进程的struct file_struct
4. 将file的地址存入到fd_array中, 建立映射关系
5. 返回数组下标

数字0,1,2也指向对应的文件, 在打开进程时,会默认打开三个文件:
![[Pasted image 20251126145341.png]]
* stdin : 标准输入流  从键盘文件读取数据  **0**
* stdout : 标准输出流  向显示器文件写入数据  **1**
* stderr : 标准错误数据  **2**

验证 ; 向fd = 1写入数据  等价于 在显示器文件打印
![[Pasted image 20251126145718.png]]

>每一种设备都有自己的读写方法 ,读写的操作肯定是不同的
>但是站在系统角度, 我们对任何设备的读取/写入都是同一套函数(open,write,close

其实很容易想到Java中的多态, 子类继承父类的属性和方法, 可以对方法重写, 比如有个write函数, 子类继承write方法, 可以实现自己的write方法, 但是C语言是个面向过程的语言, 没有类的概念, 那是如何实现的呢?

通过函数指针实现  不需要关注每个硬件的具体的实现方式  通过函数指针的方式实现  一切皆文件  
通过同一种struct file实现  用c语言实现类   属性可以通过struct实现  那方法呢?多态  同一个方法,在运行的时候表现出不同的形式  调用不同的函数   

Linux中一切皆文件  --- Java中一切皆对象
一切皆文件的思想本质上就是**多态**的思想, 同一个方法,在运行时表现出不同的现象, 在Java中可以通过继承+重写的方式实现(类 = 属性 + 方法), 在C语言中, 我们可以使用struct来实现, 关键在于如何实现像Java中的**类重写**, 通过函数指针实现, void(* read), 我们都叫read, 但是指向不同的实现方式(不同的硬件设备对应的read方法)


**打通上面若干问题**
用户级的缓冲区    内核级文件缓冲区
在OS内部, 系统在访问文件时, 只认文件对应的fd

**如何理解C语言通过FILE* 访问文件**
![[Pasted image 20251126150233.png]]
无论怎样, 肯定是在C语言的库中, 使用的系统调用, 呈现给我们的实际是对系统调用的封装
FILE 是一个C语言提供的**结构体类型**  在这个结构体内部一定对fd进行了封装  
_ fileno  就是对fd的封装
![[Pasted image 20251126150600.png]]
> C语言中对于文件的操作就是对系统调用的封装,封装了系统的细节

C语言为什么要这么做 -- 为了适配不同的操作系统 -- 不同的操作系统有不同的系统调用
C语言具有跨平台性, 在函数层面使用的都是fopen, 但实现的方法是对不同操作系统的系统调用的封装

不同的语言封装的方式不同, 但目的都是为了实现跨平台性, 内核都是一样的, 都是对系统调用的封装, 我们学习的其实是**语法**
c语言是通过编译条件实现跨平台, Java是通过虚拟机实现跨平台, python是通过解释器实现跨平台

**再次理解write/read函数**
无论是读文件还是写文件,本质上都是**拷贝函数**, 都要先把存储在磁盘中的文件内容存储到内存中的**内核级文件缓冲区中**, 后续写入内容, 需要现在次缓冲区中写入, 后续再由OS刷入磁盘
## 应用
ls /proc/pid 可以进行查看   还有一个fd目录   默认打开了  三个流文件
![[Pasted image 20251126151314.png]]
打开的终端本质上也是一个文件  每一个终端打开时, 都会默认打开三个三个fd  向打开终端的文件中输出  代码验证   
![[Pasted image 20251126152750.png]]
* 一定要加打印信息, 最开始执行代码时什么也不打印, 以为是语法的问题,一直折腾,加了perror才发现"open permission denied", 这个终端文件只有root才有权限

# 再次深入理解
**read**
```c
size_t read(int fd, void *buf, size_t count);
```
* 将从fd中读取的内容, 写入到buf之中
* 所以我们需要知道读取文件的大小
![[Pasted image 20251128143625.png]]
* 会从文件的**offset**开始进行读取
* 成功, 返回读取到的文件的字节数
* 读取时, 在文件的末尾, 直接返回0

**stat** :获取文件的状态

![[Pasted image 20251128121907.png]]
* Linux中一切皆文件, 对于文件状态的管理是通过结构体**struct stat**管理的, 第二个参数**statbuf**是一个输出型参数, 通过stat函数, 能将文件的状态存入此参数中
* 参数中 有关于文件的一些属性, ino节点, nlink硬链接数, st_size 文件的大小
* 文件 = 内容 + 属性, 对于属性的操作就是使用stat函数
 ![[Pasted image 20251128122115.png]]

> 文件描述符的分配规则 : 查打开文件的进程的fd_array(文件描述符表), 分配最小的没有使用的fd 

![[Pasted image 20251128150211.png]]

站在操作系统的角度理解
![[Pasted image 20251128151531.png]]
**重定向的本质 : 是在内核中改变文件描述符表,特定下标(指向不同的fie对象)的内容, 和上层无关**

那为什么必须要加了fflush之后才会写入到文件之中呢?
![[Pasted image 20251128152047.png]]
struct FILE* 对象的属性, 会存在一个语言级别的文件缓冲区       ![[Pasted image 20251128155414.png]]

