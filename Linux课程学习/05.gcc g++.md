# 一.基本使用

# 二.程序翻译过程
>预处理 --> 编译 --> 汇编 --> 链接
>demo1.c →(预处理) demo1.i →(编译) demo1.s →(汇编) demo1.o →(链接) demo1.exe

```bash
lsq@iv-ye36a78irk5i3z57m5br:~$ file demo1.i
demo1.i: C source, ASCII text   

lsq@iv-ye36a78irk5i3z57m5br:~$ file demo1.s
demo1.s: assembler source, ASCII text

lsq@iv-ye36a78irk5i3z57m5br:~$ file demo1.o
demo1.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

```

## 预处理
>预处理主要完成:
>	1.头文件展开
>	2.宏替换
>	3.去注释
>	4.条件编译
>初步对c语言进行**精简,优化**

```shell
gcc -E -o demo1.i demo1.c
```

![[Pasted image 20251008092909.png]]

**条件编译**
>条件编译也是预处理过程中的一个步骤,会根据不同的**条件**,编译不同条件下的代码,实现**截取代码**
>实现不同场景,不同版本的代码维护

`区分不同版本`
![[Pasted image 20251008100222.png]]
`区分不同平台`
```c
#ifdef _WIN32
	do;
#elif
	do;
#endif
```

## 编译
>预处理后的 `.i` 文件本质上还是一个c语言文件,编译是将c语言文件转换为汇编语言
>demo.i -- > demo.s

```shell
gcc -S -o demo1.s demo1.i
```
![[Pasted image 20251008100616.png]]

## 汇编
>将编译产生的汇编语言文件转换为二进制目标文件
>demo.s -- > demo.o/demo.obj


```bash
gcc -c -o demo1.o demo1.s
```
![[Pasted image 20251008101614.png]]
生成的demo1.o文件是一个**二进制目标文件**,里面存储的都是二进制程序
## 链接
>链接各种库,生成最后的可执行程序(动态库 / 静态库)
>1. 连接多程序文件 : 一个项目中可能有多个.c文件,在链接时会将这多个.c文件连接到一起
>2. 确定函数/变量的文件地址(函数在标准库的地址)

```bash
gcc demo1.o -o my.exe
```

![[Pasted image 20251008102109.png]]

>写在最后,为什么要有 预处理-编译-汇编-链接, 这四步呢,为什么不直接链接呢?
>这其实是一个历史问题,和语言的发展密切相关,程序翻译的过程本质上是一个**历史回溯的过程**
>语言的发展 和程序翻译的过程恰好相反:二进制--汇编语言--c语言
>所以,程序翻译的过程本质上就是一步步将C语言转换为二进制语言的过程
>语言和语言之间是要通过**编译器**进行交流的,利用C语言编译器将C语言编译为汇编语言,用汇编语言编译器将汇编语言编译为二进制;
>为什么不直接将C语言编译为二进制呢?难度太大!要站在前人的肩膀上
>记忆:
>gcc命令 : ESc
>后缀名 : iso
>![[Pasted image 20251008102744.png]]


# 链接库
> 编译阶段会将头文件进行展开 -- 但是头文件中存储的只是一些函数的声明,没有包含函数具体执行的机器码, 在链接阶段,会链接到具体的库,这个库中包含函数的具体实现,下面以printf函数为例,验证一下(printf 本质上也是在调库)

`查看demo1.i编译文件--函数声明`
指明头文件地址
![[Pasted image 20251008141438.png]]
printf函数声明
![[Pasted image 20251008141542.png]]
>在这一步,会进行检查,检查传入的函数参数类型是否正确,我们常说的编译错误就是指在编译阶段出现的错误

`查看链接方式`
![[Pasted image 20251008141809.png]]
* `dynamically linked` : 动态链接

**总结**
* 头文件--有这个函数  告诉编译器   存储的是函数的符号引用
* 标准库  -- 函数的具体实现  怎么做  根据符号引用去标准库中查函数的具体实现(机器码)

是什么 : 程序和库结合的过程
为什么 : 站在巨人的肩膀上(无需自己手写priintf的机器码), 提高开发效率
# 链接库的分类
>在Linux中主要分为两类 : 
>	动态链接库(共享库  .so)
>	静态链接库(静态库  .a) 

![[Pasted image 20251008143007.png]]


![[Pasted image 20251008143421.png]]

* 饿汉模式/静态库 : 在编译/启动时直接准备好所有需要的文件,直接将对应的机器码拷贝到内存之中, 占用空间多,但执行速度快  需要可移植性的场景,不需要提供动态库  所有环境均可运行
* 懒汉模式/动态库 : 等到真正需要时才去“加载”或“创建”，节省资源但会带来一定的运行时复杂性。
`ldd : 查看可执行程序在运行过程中 依赖了 哪些动态链接库`
![[Pasted image 20251008143906.png]]
`file : 查看文件的具体类型  可显示是动态链接还是静态链接`

![[Pasted image 20251008144117.png]]

>静态链接会在一开始就将机器码拷贝到可执行程序之中,所以体积也就比动态链接库大

```shell
gcc -o myexe-dynamiclink demo1.o  '默认是动态链接'
gcc -o myexe-staticlink demo1.o -static  '指定静态链接'
```
![[Pasted image 20251008145028.png]]
注 : Windows下 动态库dll  静态 .lib


# gcc其他命令讲解

`-x`
```shell
gcc -x <language> file1 file2 ...  '表示从这里开始,后面的文件都当做 language 的文件处理'
```

比如有时候忘记加 后缀了,就可以直接使用 gcc -x 强制编译
![[Pasted image 20251008150016.png]]





![[Pasted image 20251008150339.png]]

