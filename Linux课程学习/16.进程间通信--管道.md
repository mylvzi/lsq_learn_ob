# 0.前提
 进程具有独立性,天然的进程间通信的成本是比较高的
 进程独立性的体现 :
 1. 内核相关的数据结构是独立的
 2. 代码和数据也是独立的

进程间通信的前提 : **进程之间要能够看到同一份操作系统的资源(一段内存)**
由操作系统提供一份共享的区域, 让不同的进程都能看到这份共享区域的资源(外卖柜)

1. 一定是一个进程需要进行通信, 告诉OS创建一个共享区
2. OS肯定需要提供多个系统调用
3. 系统调用的不同, OS创建共享区的方式不同, 进程间通信的方式也不同!

进程间通信的标准 : System V标准  本地间通信
方式 : 消息队列 , 共享内存, 信号量
直接复用内核代码直接通信 : 管道 -- 命名管道, 匿名管道


# 1.匿名管道通信
>用内核中已经存在的东西 来实现进程间通信
![[Pasted image 20251205111606.png]]
* 同一份文件分别以r权限和w权限打开两次, 会在内存中创建两个file对象
* 所谓的管道文件, 就是共享区, 这个共享区就是OS提供的**内核级文件缓冲区**, 是操作系统开辟的一块内存空间
* 为了节省资源, 父子进程公用同一份文件系统资源(仍保持进程的独立性)
* 父进程打开的文件, 子进程默认会继承(只继承了文件的映射关系)

基于上图, 可以理解以下几个问题:
* 父子进程为什么都向显示器文件打印 : 父进程是bash, bash的输出流文件是fd=1的stdout, 子进程会继承父进程对于文件的映射关系, 所以子进程的输出流文件也是stdout
* 进程默认会打开三个文件,0,1,2 -- 怎么做到的 : bash是所有进程的父进程, bash进程默认打开0,1,2这三个文件, 其余子进程就会继承
* 子进程close文件, 不影响父进程继续对文件操作 : 内存级的引用计数  子进程关闭, 不影响父进程继续使用文件资源(内存级文件引用计数不为0, 只有为0才会尝试释放资源)

>目前已经有了共享区, 父子进程都可以访问同一块系统资源, 那如何通信呢?

为了实现通信, 需要遵守一个规则 : 管道的通信必须是**单向的**, 即只能一个进程读, 一个进程写
实现方式 : 
* 父进程删除r权限的映射, 只保留w权限的映射-->父进程负责向管道文件写入数据
* 子进程删除w权限的映射, 只保留r权限的映射--> 子进程负责读取管道文件数据

几个疑问:
父子既然要关闭不需要的fd, 为什么曾经要打开呢?为什么父进程要分别以,r,w打开两次
读写同时打开 -- 管道单向通信, 如果要用户设置成本会比较高  
只打开一个 -- 无法进行通信操作 -- 本质上还是不满足单向通信

可以不关闭吗?可以,只使用一个struct file即可,但是建议关闭:
1. fd_array数组是有限的
2. 避免误写, 破坏单向通信的原则



# 使用管道来进行通信操作
> 使用管道进行通信, 需要以下几步:
1. 使用**pipe**系统调用,完成管道文件的创建
2. 父进程关闭fd=0(读), 子进程关闭fd=1(写) -->父进程负责向管道文件写入数据, 子进程负责读取管道文件数据

>pipe系统调用

```c
int pipe(int pipefd[2]);
```

![[Pasted image 20251205200009.png]]这两个fd指向的是同一个文件, 只不过是打开的方式不同

## 管道的四种情况
>管道内部是空的 && write fd没有关闭, 读取条件不具备, 父进程就会进行阻塞, 等待资源就绪(管道内部有数据)

![[Pasted image 20251205204814.png]]

> 管道被写满 && 父进程 read 不读, 且没有关闭  管道被写满  子进程就会阻塞  等待资源准备就绪(管道有资源来进行写入操作)

![[Pasted image 20251205220603.png]]

>管道一直在读, 且wfd被关闭 -- read端会读取到0, 表示读取到文件结尾
![[Pasted image 20251206110822.png]]

> rfd直接关闭 && 管道一直在写入数据 -- OS会认为这个操作是一个浪费资源的操作, 会通过信号的方式杀掉写入数据的进程  -- 写入的进程会因为**异常**退出
![[Pasted image 20251206112216.png]]
## 管道的五种特征
1. **匿名管道**(anonymous pipe) : 是Linux中一种只存在于内存中, 且只能在**具有亲缘关系的进程之间**进行通信的**单向的**数据通道  不能通过名称进行访问
2. 管道内部, 自带同步机制  子进程写一条数据, 父进程就读取一条数据  执行的时候, 是按照某种顺序执行的
3. 管道文件的生命周期是随进程的(调用的pipe进程) -- 管道本质上也是文件
4. 管道文件在通信的时候, 是面向字节流传输的
5. 管道的通信方式, 是一种特殊的**半双工** -- 半双工(一应一答), 特殊指的是只能指定一端进行写入,另一端读取

# 进程池
>进程池中, 父进程需要管理的数据很多 -->先描述,再组织
>channel类 : 管道文件 和 其对应的子进程

提前开辟出来的一批子进程就是进程池, 父进程负责分配任务(master process), 通过管道文件传输要执行的任务, 子进程负责执行任务(worker)  提前开辟出来子进程可以减少创建/销毁进程带来的效率降低
![[Pasted image 20251208112057.png]]


## 1.创建信道和子进程
![[Pasted image 20251208112444.png]]
* 通过**pipe**系统调用创建管道文件
* 父进程充当写端, 负责写入向管道文件任务
* 子进程充当读端,负责从管道文件中读取任务
## 父进程控制进程, 分配任务
![[Pasted image 20251208112634.png]]
* 分配任务时, 父进程需要遵循**负载均衡**的原则, 即轮训进行任务的分配
* 发送任务, 向指定管道文件中写入数据  这里面是通过int类型的标记为传递要执行的函数任务
![[Pasted image 20251208112755.png]]

## 子进程执行任务
![[Pasted image 20251208112824.png]]
* 从管道文件中读取数据到缓冲区
* 对读取到的数据进行判断(读取到的字节数), 如果是0, 表示读取到文件的末尾, 代表父进程已经不再读取


## 回收信道资源和子进程
![[Pasted image 20251208113040.png]]
* 关闭父进程的wfd, 表示父进程不再继续写入数据, 子进程会读取到0, 且wfd关闭, 会直接退出
* 此时子进程还没有被回收, 处于Z状态, 需要通过wait来进行回收

**重点在于为什么要分开写循环呢**
![[Pasted image 20251208113335.png]]

![[Pasted image 20251208113328.png]]
原因在于,子进程会继承父进程的文件描述符表, 文件描述符表在分配的时候, 分配的原则是**分配未使用的最小的下标**, 一个管道文件是否被关闭, 取决于其**内存级的引用计数**, 只有当计数为0, 才会真正关闭
![[Pasted image 20251208114504.png]]


其他的解决方式

关闭子进程自己的写端   关闭关闭历史已经打开的写端  

# 几个解耦操作
> 管道的逻辑和子进程执行任务逻辑的解耦

![[Pasted image 20251208120112.png]]
* 实现解耦, 让子进程的代码更加通用化


>  work函数本身也是任务, 使用回调函数进一步解耦

![[Pasted image 20251208120552.png]]
> 再次理解管道

* 管道提供了一种**进程间通信的机制**, 一个pipe有两端, `int piped[2]`, 0表示读端, 1表示写端