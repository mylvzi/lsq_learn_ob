`站在OS的角度理解进程和端口号`
![[Pasted image 20260129230759.png]]
* 一个进程可以绑定多个端口号, 进程是系统资源分配的基本单位, port是一种资源
* sockfd -- fd -- IP + port, 进程使用fd_array管理多个fd -- 进程可以bind多个port



# ARP
> ARP(Address Resolution Protocal)地址解决协议
> 	IP -->MAC的转化
> 	ARP.request  广播
> 	ARP.response  单播

![[Pasted image 20260130001339.png]]

# NAT
>NAT(Network Address Translation) 网络地址翻译
>目的 : 解决Ipv4地址不足 + 保护网络安全, 多个私网ip -->唯一的公网ip -->目标服务器的公网ip -->目标服务器的私网ip
>NAT : 将私网IP --> 公网IP



**NAT后端服务, 永远bind0.0.0.0**
```css
网卡收包
  ↓
PREROUTING (DNAT 在这里)
  ↓
路由判断（是不是发给本机）
  ↓
INPUT
  ↓
Socket 匹配（bind 的地方）
```

DNAT会修改网卡报文中的目的ip, 此报文中的目的ip是公网ip, 而实际想访问的是此公网下某个私网服务器


# sk_buff
>Linux 中所有网络通信，本质上都是在不同子系统之间传递和修改 `sk_buff` 对象。
>`sk_buff` 是 Linux 内核中对“网络报文”的统一抽象对象


```c
unsigned char *head;
unsigned char *data;
unsigned char *tail;
unsigned char *end;
```

```css
head                              end
 |--------------------------------|
        |data          |tail
        |----payload---|
加包和解包, 本质都是在移动指针, 没有进行memcpy
```

# syn洪水
tcp三次握手
```css
客户端            服务端
  | ---- SYN ----> |
  | <--- SYN+ACK - |
  | ---- ACK ----> |
```

服务端接收到客户端发送的SYN报文, 会创建一个`半连接控制块`, 存储:
* 源ip+源端口
* 目的ip+目的端口

然后放入SYN半连接队列, 向客户端发送第二次握手, 注意, 此时服务端处于一种`已经占用资源的状态`
如果客户端:
1. 故意不回复ACK, 服务端的半连接控制块就会一直占用服务器资源
2. 使用其他ip再次访问服务器, 构造新的半连接控制块

会让服务器处于"服务可用, 但就是连接不上"

# 正向代理服务器
![[Pasted image 20260201165804.png]]

作用:
1. 缓存 --> 加快数据的访问
2. 追踪服务
3. 内容过滤, 访问控制
4. 负载均衡

校园网/公司服务器, 这也是为什么在公司内部无法连接远程的服务器, 外网的ip属于一种敏感信息


# 反向代理服务器
![[Pasted image 20260201170040.png]]
1. 直接暴露内网服务器 --不安全
2. 流量的负载均衡

# VPN软件的原理
首先, 我们所有的请求都会经过家里的路由器到达对应运营商的服务器
运营商的服务器会对你发送的请求进行校验, 如果你尝试访问一些非法的网站(比如www.google.com)
会直接屏蔽, 不让你访问, 那我实在想访问怎么办?只能采用一些手段`骗过运行商的服务器`
![[Pasted image 20260201170738.png]]

具体操作如下, 核心是在使用`代理软件`绕过运营商的限制

![[Pasted image 20260201171148.png]]
1. 代理软件客户端会劫持本主机所有的流量请求, 然后对发出的数据进行加密, 骗过运营商
2. 骗过运营商之后, 数据会首先发送到代理软件的服务器(香港/新加坡/...), 然后由此server请求你想要访问的服务器
3. 返回数据之后, server还会走运营商, 不过传输的resp是加密的, 所以就能骗过运营商

