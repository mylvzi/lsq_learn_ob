# 一.背景知识
## 重谈地址空间

**内存管理系统**
OS对于物理内存的管理, 是以4kb为基本单位的 = OS的文件系统一个数据块的大小, 这样做的原因方便我们进行数据的加载(从磁盘中加载到物理内存中)

需要明白一点, 就是**Linux不会直接管理物理内存**,而是使用一个结构体**struct page**管理物理内存, 大小刚好是4kb, 内存的管理都是围绕struct page进行的
* struct page并不是页框本身, 是页框的元数据
* 物理页 = 数据本体

**再次理解页表**
已知 : 
1. 页表是每个进程都会有的, 负责存储虚拟地址和物理内存地址之间的转换
2. MMU是负责转换的硬件单元, CR3寄存器存储页表的物理地址(页表基址寄存器)

深入:
1. 页表不是直接创建一个大表,存储所有的映射关系,而是一个**多级索引树**,存在**目录-子目录-子子目录--文件**这种索引关系
2. 多级索引的设计主要是为了**省内存**,本质是一种**懒加载的多级索引树**, 因为好多地址进程根本用不到, 如果一开始就直接创建索引, 反而是对内存的一种浪费
3. 那为什么要多级索引呢?为了保证顺序性, 虚拟页号是连续的, 必须现有对应的虚拟页号位置, 等什么时候用到了, 再去建立映射关系
# 二.线程的概念 和 Linux中线程的实现
* 线程是系统调度的基本单位
* 进程是资源分配的基本单位
![[Pasted image 20251221210537.png]]

* Linux中没有线程, 只有**轻量级进程**
* task_struct本质上就是线程, 我们把一个线程当做一个执行流, 之前的进程其实是**单执行流**的, 只有一个线程

>既然线程是在一个进程内部创建, 就会共享这个进程的一些资源
>直接从最底层讲解

```c
// 用户态创建线程
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);
                          
// 底层
int clone(int (*fn)(void *), void *stack, int flags, void *arg, .../* pid_t *parent_tid, void *tls, pid_t *child_tid */ );

pthread_create
  ↓
clone(
  CLONE_VM        // 共享虚拟内存
  CLONE_FILES     // 共享 fd 表
  CLONE_FS        // 共享文件系统信息
  CLONE_SIGHAND   // 共享信号处理
  CLONE_THREAD    // 属于同一线程组
)

```
![[Pasted image 20251221211946.png]]
* clone和fork很像, 都是**创建一个子进程**
* clone相较于fork,提供了更多对于**子进程的控制**, 比如 : 执行的上下文(fork是自动执行fork后面的代码的, 也就是上下文就是父进程的上下文), 共享的区域(虚拟地址空间, 文件描述符表, 信号表等)
* clone是真的**创建一个执行流**,clone函数中,有一个参数**stack**,就是专门为子进程分配的栈区, **arg**参数是子进程要执行的任务, 执行过程中创建的临时变量,函数栈等都是在子进程自己的stack上

>既然是执行流, 如何查看

```c
ps -aL
lsq@iv-ye36a78irk5i3z57m5br:~$ ps -aL
    PID     LWP TTY          TIME CMD
 435460  435460 pts/1    00:00:00 su
 435464  435464 pts/1    00:00:00 bash
 439112  439112 pts/1    00:00:00 ps
```
* LWP(light weight process) : 轻量级进程, 就是内核调度的实体
* 打印的每一行, 就是一个**执行流**
* 如果只有一个执行流,LWP就等于PID
* 也就是说!如果站在LWP的角度, PID不是唯一的, LWP才是唯一的
* OS调度的时候, 是拿着LWP进行调度的

>站在用户角度, 使用pthread_create创建多线程

```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
				void *(*start_routine) (void *), void *arg);
```
* pthread_t * thread : 线程标识符, tid
* attr : 线程的属性
* start_routine : 是一个函数指针, 本质上是**子线程的第一条用户态指令(栈的入口)**
* arg : 传递给子线程的参数(生命周期是子线程)


```c++
#include <iostream>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
// int pthread_create(pthread_t *thread, const pthread_attr_t *attr,

//                      void *(*start_routine) (void *), void *arg);

void* func(void* arg)
{
    int num = *(int*)arg;
    std::cout << "arg = " << num << std::endl;
    std::cout << "i am thread, tid = " << gettid() << std::endl;
    sleep(10);
    return NULL;
}

int main()
{
    pthread_t tid;
    int arg = 10;
    int ret = pthread_create(&tid, NULL, func, &arg);
    if(ret != 0)
    {
        perror("pthread_create");
        return -1;
    }

    std::cout << "main thread, tid = " << gettid() << std::endl;
    // 等待子线程结束
    pthread_join(tid, NULL);
    std::cout << "main thread exit..." << std::endl;
    return 0;
}
```

![[Pasted image 20251221214919.png]]
* 注 : 编译时, 要加上 `-pthread`
![[Pasted image 20251221222454.png]]

>1. 已经有多进程了, 为什么要有多线程

* 首先从创建上来说, 进程创建成本更高(需要创建新的内核管理数据结构, 如果发生写时拷贝代码和数据也要重新开辟), 创建线程的成本就比较低了, 只用创建一个task_struct, 公用进程的资源(地址空间,页表, fd,信号屏蔽数
* 从调度成本上来说,  线程的调度成本更低, 不需要切换地址空间和页表
* 从销毁上来说, 线程的销毁成本也更低, 只需要删除task_struct

**从底层理解线程切换的成本更低**
首先要明确, 线程有哪些私有的部分:
* 上下文信息 : 使用寄存器进行保存
* 栈区 : 每个线程在执行过程中都会产生自己的临时变量

所以,线程的切换也涉及到**上下文切换**即寄存器状态切换

进程的切换会切换:
1. task_struct
2. 进程地址空间(mm_struct)
3. 页表
4. 管理的数据和代码

对于线程来说, 也会切换task_struct, 所以这部分不会带来差异,性能差异在于地址空间!
>CPU为了加快访问速度, 在CPU内部会使用cache来缓存经常访问的虚拟地址和物理地址之间的映射, 具体会使用TLB(Translation Lookaside Buffer)地址转换后备缓冲区

访问内存, 涉及到从CPU向内存的访问, 速度会变慢

线程的切换, 不会更改页表, 即原来的映射关系保持不变,所以原先在TLB中存储的映射关系仍然有效
如果是进程, 页表发生变化, 后续的访问都是通过多级页表来进行访问的,多级页表的访问是内存级的,速度更慢

从硬件上来说,地址空间的切换本质上是CR3寄存器状态的变化!

>2. 不同系统对于进程和线程的实现都不一样
>只不过是实现方式不同罢了, 只要保证线程在进程内部运行, 并且是CPu调度的基本单位就行

![[Pasted image 20251221223509.png]]
# 三.进程与线程

### 优点
IO密集型应用和计算密集型应用

### 缺点
健壮性比较低 : 如果其中一个线程发生了异常, 会影响其他线程, 但是进程之间通过进程地址空间实现了隔离性



如何理解多个线程共享文件描述符表
每种信号的处理方式
当前工作目录
用户id,组id


# 四.线程的控制

编译时为什么要有`-lpthread`, Linux没有线程,只有轻量级的进程,但是站在用户态,我只认识线程, -pthread的本质其实是对Linux中轻量级进程的封装, 对外叫做线程,但是底层都是轻量级线程这一套操作

## 线程的创建
**pthread_create()**
```c++
    // int arg = 10;  在mainthread的stack上创建的临时变量
    int* arg = new int(10);// 在堆上申请空间  避免在main函数的栈上直接使用变量
    int ret = pthread_create(&tid, NULL, func, (void*)arg);
```
* 传递给线程参数时, 不推荐直接传递在main函数上创建的临时变量, 这是属于main thread的stack, 而线程之间的stack是私有的,访问其他thread的stack是不规范的
* 直接在堆上开辟,作为参数传递给新的线程
**获取线程tid的两种方式**
1. gettid()
2. pthread_self()

**区分内核级tid和用户级tid**
```c++
    std::cout << "用户级 tid = " << pthread_self() << std::endl;
    std::cout << "内核级 tid = " << gettid() << std::endl;
    
    用户级 tid = 140501229262592
	内核级 tid = 729126
```

* pthread_self()获取的是用户级tid, 本质上就是一个 **虚拟地址**,只是glibc管理线程的数据结构
* gettid()获取的事内核级tid,是内核管理线程时真正使用的tid, 内核调度器真正看到的执行流

```c++
┌──────────────────────────┐
│      用户态（glibc）      │
│  pthread / libpthread    │
│                          │
│  pthread_t               │  ← pthread_self()
└────────────▲─────────────┘
             │ 系统调用
┌────────────┴─────────────┐
│        内核态（Linux）     │
│     task_struct / 调度器  │
│                          │
│  pid / tid / tgid         │  ← gettid()
└──────────────────────────┘

```

**线程执行完毕后的返回值**
>全面理解传递给新执行流的参数 -- 不知可以传递参数,也可传递类的地址  既然是类,传递类就可以传递参数,方法等


![[Pasted image 20251222154735.png]]
![[Pasted image 20251222154758.png]]
```c++
void* (*start_routine) (void*)
是一个函数指针, 返回值是void*, 参数也是void*
这样设计最大的好处就是灵活性, 允许将类型作为返回值/参数
```
## 线程的等待
```c++
pthread_join();// 必须是正在运行的线程才可以被等待
int pthread_join(pthread_t thread, void **retval);
```



```c
       The  pthread_join() function waits for the thread specified by thread to terminate.  If
       that thread has already  terminated,  then  pthread_join()  returns  immediately.   The
       thread specified by thread must be joinable.

       If  retval is not NULL, then pthread_join() copies the exit status of the target thread
       (i.e., the value that the target thread supplied to pthread_exit(3)) into the  location
       pointed  to  by  retval.   If  the target thread was canceled, then PTHREAD_CANCELED is
       placed in the location pointed to by retval.

       If multiple threads simultaneously try to join with the same thread,  the  results  are
       undefined.   If  the  thread calling pthread_join() is canceled, then the target thread
       will remain joinable (i.e., it will not be detached).
```
* 被等待的线程必须是**joinable**(如果是detach, 就是unjoinable)
* 如果retval不是NULL,将会存储目标线程的退出状态
* 如果目标线程被取消了, retval中将存储**PTHREAD_CANCELED(-1)**
* 如果多个线程同时等待同一个线程,retval将是未定义的(join的本质是回收 + 取结果一个线程, 回收只能回收一次)
* 如果calling thread被cancel,则target thread仍保持joinable


![[Pasted image 20251222161318.png]]
![[Pasted image 20251222162812.png]]
## 线程的终止
```c
retun (void*)arg;
pthread_exit(arg);
int pthread_cancel(pthread_t thread);  // 取消一个进程
----------------
exit(1); 会让整个进程退出, 所有的线程都会被终止
```
* 注 : 尽量保证main thread最后一个退出, 因为main thread代表进程!*

## detach
>main thread不join, 让子线程执行完毕, 自动完成资源的回收(主线程不需要再去管理)
>仍然在线程内部, 但是不需要被join了

```c++
int pthread_detach(pthread_t thread);
```
![[Pasted image 20251222201907.png]]![[Pasted image 20251222201955.png]]
* 被detach的线程, 不允许被其他线程使用pthread_join 进行等待
* 本质含义 ;这个线程的资源不需要再被其他线程回收, 只需要通过系统回收即可

