# 前置知识（站在系统角度理解tcp通信）
`网络通信的本质 -- 进程间通信`
`网卡也是外设, 在linux系统角度, 网卡也是一个文件`
![[Pasted image 20260127000240.png]]

**结论1:read, write,send, recv函数的本质都是拷贝函数**
回顾文件系统:
![[Pasted image 20260127000600.png]]
* 写入文件 -- 根据fd找到对应struct file的文件缓冲区 -- OS在合适的时机刷入磁盘

类比TCP通信:
* write写入要通信的数据 -- 拷贝到TCP的发送缓冲区 -- OS等待合适的时机刷入网卡, 通过网络传输数据
* IP + PORT确定socket, 即确定一个sockfd, 一个sockfd就是一条连接, 一条连接对应两个缓冲区!

**结论2: 发数据的本质 -- > 从一方的发送缓冲区把数据通过网络和协议栈拷贝到接收方的接收缓冲**
**结论3: tcp支持全双工通信的本质 --> 有两个文件缓冲区**
**结论4: tcp叫做传输控制协议的本质**
数据会先存储到发送缓冲区中, 什么时候发送, 怎么发送, 发送出错怎么办, 这些==用户不需要考虑==
直接交给TCP即可, TCP会处理好这些事情, 所以叫做传输控制协议, 这就跟OS控制文件什么时候写入到磁盘一样, 底层其实也是OS控制什么时候写入到网卡!!!!

**结论5: tcp的全双工本质上也是一种生产者消费者模型**
文件缓冲区就是`临界资源`

**结论6:IO函数阻塞的本质-->维护数据同步关系**

# 一.序列化和反序列化初识
站在OS角度理解
![[Pasted image 20260127001726.png]]
* 序列化和反序列化本质是在应用层和传输层之间一套`软件层`
* 为了实现解耦, 不能直接按照通信双方规定好的Protocal裸露传输数据
* 应用层仍然使用规定好的结构体表示要传输的数据, 通过序列化, 转换为用于在网络传输的`字符串数据`
* 发送到接收方, 再通过`反序列化`, 将字符串还原为规定好的格式
* 协议-->双方规定的数据结构化表达格式
* 序列化 : 结构化数据 --> 字符串
* 反序列化 : 字符串 -->结构化数据
* 实现方式 : Json, xml, Protocal等

理解OSI七层网络模型
* 应用层 : 
* 表示层 : 通信设备双方按照Protocal约定好的格式进行通信, 涉及到序列化和反序列化
* 会话层 : 建立连接状态

