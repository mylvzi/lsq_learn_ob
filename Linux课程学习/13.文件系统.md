>讨论的文件都是**被打开的文件**, 然后OS对打开的文件进行管理(struct file)
>但是绝大多数的文件都是未被打开的,都是存储在磁盘上的
>把文件加载到内存中, 需要先让OS找到文件在磁盘中的存储位置,(路径 + 文件名称) 然后加载到内存之中
>就像快递站存储快递一样, 我们要研究, 磁盘究竟是怎么对文件进行管理的, 从而实现快速的存取?

# 1.物理磁盘

**计算机只认识二进制**
0,1的本质其实是光信号/各种电脉冲信号
笔记本目前大多数都是SSD

盘片 : 可读可写  一片两面都可以存储数据
磁头 : 用于进行寻址  每一面都有一个磁头
磁头和旁边不能挨着, 因为两个设备都是在进行高速旋转的   是悬浮在磁盘上面的
通过马达带动磁盘和磁头进行转动
磁盘之前都是机械结构, 就注定了无法做得很薄, 同时磁盘也比较金贵

# 2.磁盘的存储结构
磁盘是一个机械设备, 且是一个外设
CPU和内存之间的数据交互是通过**光电信号**传输的, 且非外设

读写的基本单位是扇区  512字节   
每一个同心圆就是一个磁道, 多片组合起来, 磁道之间就会形成一个**柱面**
**如何定位到是哪一个扇区**
1. 先找到对应的磁头(header)
2. 找到对应的磁道(Cylinder)
3. 判断是磁道的哪一个扇区(Sector)

**CHS**寻址法, 是机械结构 ->软件地址的直接映射
通过这三个物理结构的地址, 就可以确认到文件在磁盘上的地址

```
  多张盘片（platter）
  ├── 每个盘片有两个面（上、下）
  ├── 每个面对应一个磁头（Head）
  ├── 圆形的盘面被分成多个同心圆（柱面 Cylinder）
  └── 每个柱面被分成多个弧段（Sector）

```

>盘片的高速旋转是为了定位扇区
>磁头的高速旋转是为了定位磁道

注 : CHS寻址法已经是一个比较老的定位方法了, 主要是由于现代存储设备的快速发展, 导致容量和复杂度比之前大大提高, CHS已经不适用了, 目前常采用LBA逻辑寻址法
# 3.OS对磁盘存储的逻辑抽象
> 文件的存储站在硬件的角度其实就是**占几个扇区的问题**
> OS如何对磁盘这种物理设备进行逻辑抽象

CHS寻址法严格依赖硬件的物理结构, 物理结构一旦发生变化, 对应的软件也要发生更改

  把磁盘拉直, 可以形成一个线性的逻辑结构, 磁盘的基本读取单位是**扇区**, 所以可以将这个线性的逻辑结构当做一个**数组, 数组的元素是扇区(sector)**
  建立index和 CHS之间的映射关系
文件 = 很多个sector的下标 disk_array[N]

一般而言 OS和磁盘进行交互时, 读取的基本单位是**4kb = 8个扇区, 也叫做一个数据块**
这8个扇区是连续的

文件 = 很多的数据块集合
对于操作系统来说, 只需要知道第一个起始块 + 磁盘总大小就行, 因为基本的读取单位是块, 又人为规定 一个块是8个扇区  所以只需要知道第一个块的起始地址, 往后读取时, 直接往后连续读取8个扇区(一个块)即可

LBA blocks[N]  逻辑区块地址
**文件 = 很多个LBA地址**  

但是直接管理整个磁盘会比较复杂, 为了更好的进行管理,会进行**分区操作**
分区之后还会进行**分组**

![[Pasted image 20251130223405.png]]

每一个分组, 也是一个磁盘级的文件系统

>文件 = 内容 +属性, 无论是内容还是属性, 都是数据, Linux中文件系统的管理是将**文件的属性和内容分开进行存储**

![[Pasted image 20251130230632.png]]
* 数据块 ; 文件的内容都是存储在此结构, 占据磁盘级文件系统的空间最大, 内部是以4kb为基本单位的数据块
* 块位图 : 比特位的位置, 表示块号, 比特位为1, 表示此数据块已经被使用
* inode table ; 存储文件的属性, 如文件的大小,所有者,权限等等, 在Linux中, 文件的属性是一个**固定大小的集合体**, 其实就是一个结构体, struct inode 结构体, 大小是固定的, 128字节, 一个文件一个inode属性集合(inode结构)
* inode bitmap : 用于标识inode结构体是否空闲, 可用,


> inode表示文件的属性, 是对文件属性的逻辑化抽象, 也是描述一个文件**元数据结构体**

文件内容数据的存储 --> Data Blocks
文件属性数据的存储 --> inode table --> struct inode

**细节问题**
> inode是按照区划分的  通过superblock和GDT  存储分区中每一个分组的inode范围

同一个分区之中, inode号是唯一的,是不能重复的
不同分区之间, inode号是可以重复的

>ext4文件系统结构 -- inode号是如何定位到文件的

文件 = 属性 + 内容
inode号找到inode结构体 -->找到了文件的属性数据
struct inode ->datablocks[N]  -->存储的是**block pointers**, 指向文件数据在数据块中的地址
但这个数组并不是完全的一一映射, 因为这样每个文件可表示的文件大小太小了(datablocks一般是15字节)
实际上, ext4文件系统中, 对databloakcs进行的划分, 氛围直接块 和 **间接块**
```
12 个直接块
1 个一级间接块
1 个二级间接块
1 个三级间接块

```

```css
inode
 ├── direct[0..11] 指向数据块
 ├── indirect1 → 指向一个 block，里面全是数据块号
 ├── indirect2 → 指向 block（指向更多 block）
 └── indirect3 → 指向 block（指向更多 block）
```

有的数组元素指向的是索引数组, 指向的Data Blocks中其他数据块, 内部也是一个索引数组
相当于简历了**多级索引**

> 拿到inode号才可以找到文件
> 1. 一直都是拿文件名找文件的啊, 怎么拿到inode号的
> 2. struct inode中没有存储文件名这个属性

**结论 : 文件名这个属性存储在文件所处目录的内容中**
目录也是文件, 文件 = 属性 + 内容, 那目录的内容是什么呢?
目录的内容就是**目录下所包含文件, 文件名和文件对应的inode编号的映射关系**

1. 一个目录下不能建立同名文件 -->在同一个分区之内, inode号不能重复, 是唯一的, 要建立文件名和inode号的一一映射关系
2. 查找文件的顺序: 根据文件名找到inode编号 --> inodeBitmap&inodeTable-->struct inode
3. 目录的**r权限**, 删除了目录的r权限, 就无法查看当前目录有哪些文件 -->不知道inode编号,也就查不到文件名称  r权限,本质是允许我们读取目录的内容, 没有了就无法读取目录的内容, 而目录的内容就是inode和文件名的映射
4. 目录的**w**权限, 本质是允许我们对目录的内容进行修改, 就是允许建立文件名称和inode编号的映射关系, 没有w权限, 就无法创建文件, 本质是无法创建定位文件的inode编号

>如何理解文件的增删查改

`增` : 根据inode编号 -- inodeBitmap&inodeTable-->struct inode --> datablocks -->datablocksBitmap&datablocks -->在datablocks上分配更多的数据块

`删` : 在删除的时候, 只需要将inodeBitmap 和 DatablocksBitmap置为0即可, 实际的文件内容并不会被删除, 但是后续如果有新的文件被创建/修改, 可能会覆盖这些**无效的数据块**

>一个疑惑的点 : 找到文件的inode -- 找到目录的内容
>但是要找到目录, 首先要找到目录的inode, 当前目录的inode存储在上级目录的内容中
>往上寻找, 一直到**根目录**, 就不在寻找, 因为根目录在一开机的时候就已经被分配好了
所以, 要找到文件的inode, 实际上需要做一个**逆向的路径解析**, 需要一直找到根目录,然后向下搜索,直到找到该文件所属的目录, 根据目录的内容,找到该文件对应的inode编号!
所以在Linux中想要定位一个文件, 都要含有路径,

**1.每次查找文件都要从根目录开始吗?**
不需要, Linux操作系统中, 会对经常访问的文件进行路径缓存


**2.根据inode定位文件, 但是不同分区inode可以重复, 关键在于 文件 是在哪一个分区**
分区 -->写入文件系统(格式化) -->挂载到目录 -->后续可以直接访问这个目录
* 分区 : 只是对磁盘进行范围划分, 并不包含元数据
* 格式化 : 在分区/磁盘上**重新写入**文件的元数据结构, 初始化空文件系统, 会覆盖元数据区域, 导致旧的文件系统无法再访问旧数据, 表现为**清空数据**, 所以说,格式化的本质是**写入新的文件系统**, 让操作系统能够管理
* 挂载到目录 : 格式化后的分区, 是一块**独立的区域**, 需要和操作系统建立**目录树结构**, 所以说我们只需要直到是哪一个目录, 就知道是哪一个分区

为什么打开文件没有带路径?启动的进程已经有了!**CWD**环境变量, 根据CWD+文件名拼接, 就得到了文件的绝对路径

Linux内核在被使用的时候, 一定会存在大量的解析完毕的路径, 要对访问到的路径进行管理

> struct dentry, (directory entry)路径缓存结构, 目录入口
> Linux设置一个专门的结构体, dentry, 存储**文件名 -->inode**的映射关系
> 被称为**路径层**

```c
struct dentry {
    struct qstr d_name;      // 文件名（字符串）
    struct inode *d_inode;   // 指向 inode（文件元数据）
    struct dentry *d_parent; // 父目录
    ...
};
```


|字段|含义|
|---|---|
|d_name|文件名，例如 "a.txt"|
|d_inode|这个文件名对应的 inode（文件的真正信息）|
|d_parent|父目录 dentry|
|d_subdirs|子目录 dentry|
|d_flags|状态、缓存标志|最重要

dentry最重要的功能是**提供了dentry cache**,来缓存大部分的已经解析过的路径
* 速度远快于inode chche
* 大部分文件查找不需要访问磁盘
* 几乎所有的路径解析都依赖dentry

Linux采用的是VFS(Virtual File System)虚拟文件系统, 核心有三层
```ini
dentry = 路径层  加快路径访问/快速定位
inode  = 元数据层  定位文件的属性和内容
file   = 打开文件时的会话层  struct file
```