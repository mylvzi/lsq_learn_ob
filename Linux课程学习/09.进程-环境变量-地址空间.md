# 1.对于操作系统的理解
>操作系统是一个软件, 用于对计算机软硬件资源进行管理
>管理的本质是对被管理者数据的管理,任何管理都要符合**先描述,再组织**
>描述:描述被管理者的属性,需要管理什么
>组织:采用什么样的方式进行管理  采用什么结构管理

![[Pasted image 20251029092721.png]]
`向下`
操作系统不直接管理硬件,而是通过**驱动程序**进行硬件资源的管理
`向上`
用户不能直接访问操作系统的数据,只能通过**用户操作接口 + 系统调用接口**间接访问,这个system call是由操作系统提供的,不让直接访问本质上还是为了维护操作系统的组织管理(不能随便让人进入)

printf -- 传入参数,调用系统接口 -- 将数据传输给操作系统 -- 操作系统通过驱动程序,将用户传入的参数输出到显示器文件上

管理的是一个一个硬件:
描述 : 这些硬件都有哪些属性,需要提供什么参数进行管理
组织 : 创建结构体描述一个硬件,众多硬件之间通过**链表**这种数据结构管理


用户操作接口 -- 操作系统提供的 system call使用起来还是有门槛的,程序员对system call进一步封装可以简化使用,同时提高 使用的灵活性,降低耦合度,开放度较高  [[为什么说c,c++具有跨平台性]]

# 02.进程
>进程 = pcb + 程序对应的数据和代码
>Linux下 : 进程 = task_struct + 程序对应的数据和代码
>一定要明白,进程不仅仅是加载到内存中的可执行程序,如何是的话,操作系统并不知道怎么管理
>pcb(process control block) : 进程控制块
>我们会运行多个可执行程序,在内存中会同时出现多个可执行程序,如何管理呢?先描述,在组织
>描述 : 使用pcb(struct)进行描述,描述进程的属性  所有属性 + 内存指针(指向内存中可执行程序的位置)
>组织 : pcb之间通过链表关联
>所以,对进程的管理本质上也是对链表进行组织管理,链表上的节点是一个一个pcb(task_struct)
>也可以说,对进程的管理就是对pcb的管理
>操作系统本质上也是一个软件,软件就是可执行程序,操作系统本质上也是存储在磁盘上的二进制目标文件,所谓的运行操作系统就是运行一个可执行程序,运行可执行程序的过程是"现将存储在磁盘上的可执行程序加载到内存中,让cpu从内存中获取代码和数据去执行程序,只不过每次开机都会先运行操作系统这个程序

![[Pasted image 20251029110440.png]]

`pid`:进程控制块的唯一标识
```shell
ps ajx | grep demo.exe  # 系统层面查看进程 ps ajx本质上是Linux操作系统的内核命令
getpid # 用户层面获取pid  本质是一个用户接口  用户不能直接访问操作系统管理的数据
ctrl + c # 用户层面终结进程
kill -9 pid # 系统层面终结进程
```
![[Pasted image 20251029120158.png]]

``ppid``:当前进程父进程的pid
![[Pasted image 20251029160626.png]]
这个父进程pid是什么
![[Pasted image 20251029160731.png]]
发现是bash, bash是王婆,可以理解为用户操作接口,是一个命令行解释器,每次运行可执行程序时,都会创建一个新的子进程来执行对应的逻辑,bash本身负责核心业务即可,不影响整个shell外壳
在bash这个父进程下面创建一个新的子进程,去执行需要需要执行的指令

![[Pasted image 20251029172611.png]]

[[fork函数官方文档介绍]]

**/proc文件夹**
> proc(process information preudo filesystem) 进程伪文件系统
> 是一个由Linux内核提供提供的一个文件, 用来暴露系统内核和进程的相关信息
> 每当新创建一个进程, 此文件中就会多一个 pid
> [[proc文件详解]]



# 进程状态
`R Running` : 进程正在运行
![[Pasted image 20251029234837.png]]
`S Sleeping in an interruptible wait` : 可中断睡眠等待
比如进程正在等待资源就绪  常见于和外设交互时  比如如果代码中含有**printf**, 对应的可执行程序就处于S状态  表示进程暂时不暂用cpu
![[Pasted image 20251029234952.png]]
![[Pasted image 20251029235009.png]]
为什么"打印"这个操作会让进程处于S状态呢?printf的本质是向显示器文件输出内容,cpu的运算速度很快,但是将数据拷贝到磁盘速度很慢,此时一直在进行磁盘IO  

进程进入`可中断睡眠状态`的原因
>当前进程没有需要他去执行的任务了, 必须等待某个事件的到来(IO完成, 接收到信号, 资源可用

验证 : Linux中的命令本质上也是文件,也是可执行程序
cat 命令本质上是从键盘文件中读取数据, 当你使用cat命令时, 会先启动一个进程

![[Pasted image 20251030101857.png]]
![[Pasted image 20251030102011.png]]
`T  Stopped (on a signal)` : 进程被信号机制作用导致暂停
![[Pasted image 20251030102518.png]]
![[Pasted image 20251030102641.png]]
```shell
kill -19 pid # 向进程发送信号, 让他暂停  SIGSTOP
kill -18 pid # 唤醒被暂停的进程, 继续执行任务  SIGCONT
```
`t  Tracing stop (Linux 2.6.33 onward)` : 追踪停止
打断点的本质就是向正在执行的进程发送信号, 让他暂停, 通过这种方式让进程暂停, 进程会进入**t**状态

`D  Waiting in uninterruptible disk sleep`
不可中断的磁盘睡眠状态, 这个状态比较特殊;我们知道, 所有的可执行程序要想被执行必须被加载到内存中运行(包括操作系统), 但是内存中的空间是有限的, 如果服务器压力过大/传输一些过大的数据, 可能会导致内存空间不足, 这时候 **操作系统有权利杀掉进程来维护系统的正常运行**, 但是如果杀掉的进程是一些比较重要的进程, 会带来意想不到的麻烦(比如把银行交易这个进程杀掉), 为了避免这种情况发生, 可以给这些不想被杀掉的进程设置一个**标记**, 即将其stat设置为D, 表示不可被中断, 这样操作系统也就不会杀掉对应的进程

`Z zombie` : 僵尸进程
>描述的是父子关系  一个子进程运行完毕之后, 需要等待父进程去读取子进程的退出信息(因为父进程需要知道子进程干了什么,干的怎么样)  如果父进程一直不去读取相关的退出信息, 该子进程的状态就是僵尸进程  task_struct 会记录相关的退出信息
>父进程还在, 但是子进程运行完毕
![[Pasted image 20251031110908.png]]

`孤儿进程`
>顾名思义, 父进程先被回收, 比子进程先结束掉, 那么子进程永远无法被读取退出信息, 也就无法被回收, 这样的进程称之为孤儿进程
>为了不造成内存泄漏, 在Linux中一般是让pid=1的进程去处理孤儿进程(操作系统本身去回收对应的进程)


注 : 我们写的可执行程序/使用的命令, 并没有去回收啊?实则不然, 可执行程序/命令他们的父进程都是**bash**, bash会在可执行程序执行完毕后,自动的执行回收操作


```shell
while :; do ps ajx | head -1 && ps ajx | grep demo1.exe | grep -v grep;sleep 2; done
# 每隔两秒查找进程的状态  并过滤 grep相关的进程(使用grep搜索的时候本质上也是创建一个进程去执行操作)
# grep -v  invert 不匹配后面的搜索结果
```

>我们常说的**进程状态**,本质上是**cpu和进程位置关系的讨论**
# 3.进程的运行,阻塞,挂起
## 运行
![[Pasted image 20251031093042.png]]
* 在运行队列中的进程,此时的状态就是运行状态, R状态

## 阻塞
>以一个经典的阻塞状态为例, C语言的scanf为例讲解
>首先, 操作系统是一个进行**软硬件资源管理的**程序, 软件资源管理就是进程的管理, 什么时候执行是由 cpu的 struct runqueue和调度算法决定的
>那如何管理硬件资源呢?先描述,在组织
>描述 : struct device 进行管理
![[Pasted image 20251031111959.png]]
* 状态变化的本质 : pcb/task_struct被连入到不同的 队列中, 运行状态就是连入 cpu的运行队列; 阻塞状态就是连入对应硬件资源的等待队列中
* 进程在切换的过程中, 最重要的是要通过寄存器保存进程的临时数据,也就是上下文, 需要知道进程执行到什么地方, 都干了什么, 当再次轮转时才能继续执行未执行的代码

# 进程优先级
![[Pasted image 20251111223909.png]]

>1.什么是优先级  : 指定进程获取**某种资源(cpu资源)**的先后顺序 
本质就是一个数字, Linux中优先级数字越小,优先级越高
![[Pasted image 20251111223923.png]]

>2.为什么要有优先级

进程访问的资源(cpu)有限  而系统中的进程是更多的(学生打饭), 为了保证基本的秩序,需要进程之间按照某种规则(调度算法)去占有cpu资源
操作系统 : 分时操作系统, 调度原则一般都是遵循**基本的公平**的机制

>3.Linux中优先级的特点 && 查看方式

```bash
ps -al # 查看进程的优先级
```
![[Pasted image 20251111224821.png]]

PRI : 表示此进程的优先级
NI : nice值, 对进程优先级的调整系数  能够动态的调整进程优先级(特殊情况特殊处理)
特点 :
1. 新的优先级 = 优先级(默认值就一直是80) + nice值  
2. **nice值(NI)** 并不能任意调整,而是有范围的    top + renice    nice [-20, 19]  

**使用top命令修改进程优先级**
top -->按下r -->输入要修改的进程id -->输入要更改的NI值
![[Pasted image 20251111225157.png]]
![[Pasted image 20251111225340.png]]

`nice`
![[Pasted image 20251111230305.png]]
* 以一个修改后的进程优先级去执行程序
* -20 ~ 19
```bash
nice -n -5 ./myprocessq
```

**概念理解:**
并行 : 多个cpu上, 同时有多个进程在运行
并发 :  在一个cpu上, 通过进程调度算法, 使得多个进程在一个时间段内快速交替执行
独立性 : 进程与进程之间互相隔离, 具有独立性  比如杀掉父进程, 子进程仍然能运行
竞争性 : cpu资源是有限的, 必然存在竞争问题
# 命令行参数和环境变量
## 命令行参数
>所谓的命令行参数就是指你在Linux的终端中输入的各种指令包括其选项(ls -a)
>1.为什么要这么干 : 可执行程序中有多个选项, 可以让用户通过输入不同的选项执行不同的操作

>2.谁干的 : bash 命令行解释器
>命令行中启动的程序, 父进程都是bash, bash叫做命令行解释器, 是对命令行参数进行解释, 通过两个参数解释: int argc, char* argv[]; 第一个参数一定是可执行程序的路径, 剩下的参数是执行的选项
>如何解释呢 : 通过类似于**split(" ")**
>将输入的命令行参数字符串切割为一个字符串数组, 存储到 char* argv[]中
>bash内部会创建子进程, 将解释的参数传递给该子进程(子进程能看到父进程的数据), 去执行匹配选项的程序/函数
>ls -l || ls -al 为什么会产生不同的效果呢 -- 本质上是bash解释器将命令行参数解释之后, 然后创建ls子进程去执行对应的程序操作(bash是父进程)

![[Pasted image 20251112145612.png]]


`下面实现一下: 在自己的进程中模拟选项`
![[Pasted image 20251112151607.png]]
## 环境变量
> 为什么直接输入 ls就能直接运行  demo1就无法直接运行??
> 对于 ls/mkdir这种命令, 是一种系统级命令, 要被经常使用, 再使用的过程中我们要输入命令行参数让bash去知道 需要执行的可执行程序的位置(argv[0]), 为了方便使用这些系统级命令, 将其提前存储在 **PATH(环境变量)** ,执行时bash会先从PATH中查询路径

```bash
lsq@iv-ye36a78irk5i3z57m5br:~/file4$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```
* 环境变量之间通过 : 分割, 其中usr/bin就是ls命令所在的路径
![[Pasted image 20251112152235.png]]

**如何把可执行程序也当做环境变量**
```bash
mv demo1 /usr/bin # 直接将可执行程序移动到环境变量的目录下
PATH=$PATH:/home/lsq/file4 # 在PATH后面追加
```
![[Pasted image 20251112152617.png]]
![[Pasted image 20251112153003.png]]

当我们重新打开终端时, 发现原先的环境变量又恢复到默认了, 这说明
在登陆Linux系统, 默认查到的环境变量是**内存级的**, 那么添加环境变量本质上也是在内存上添加的, 随着机器重启, 在内存上添加的环境变量就会消失, 也就表名, bash进程在启动时, 会先读取存储在磁盘上的**配置文件**, 从配置文件中获取环境变量参数,
配置文件主要有两个:
bashrc 和 profile文件
![[Pasted image 20251112153905.png]]

/etc/bashrc 系统级的配置文件

**其他环境变量**
>上述的PATH只是环境变量中的一个, 此外还有很多其他的环境变量
>基于上面对于PATH的理解, 我们知道环境变量本质上就是一个字符串, 同时也是一个**全局配置的参数**, 是通过 key = val进行组织的

`env : 查看所有环境变量`
![[Pasted image 20251112210352.png]]
history
$PATH : 可执行程序搜索路径
$HOME : 指向当前登录的用户
$HISTSIZE : 最大的记录命令数目
$SHELL : 使用的终端解释器
$PWD : 当前文件路径

**自定义环境变量**
`export NAME=lsq`
![[Pasted image 20251112211217.png]]
unset NAME   取消环境变量
>环境变量是一个全局的参数, 从变量生命周期上说, 环境变量是全局的

![[Pasted image 20251112211333.png]]
为什么也能打印呢?因为这里的hello是通过shell创建的一个**本地变量**, 从生命周期上说就是一个**局部变量

## 再次理解环境变量,系统
### 获取环境变量的三种方式 -- 代码实现

**方法一**
使用一个全局变量 **environ**  存储着环境变量
```bash
extern char **environ # 二级指针
```
![[Pasted image 20251112212157.png]]
* environ 是一个二级指针, 指向一个**指针数组**,这个指针数组指向的内容是字符串
* 数组的最后一个指针是NULL
* 通过fork创建的子进程, 会继承父进程的环境变量参数
bash会默认维护两张表
main函数的参数  0, 2, 3个参数
```c
#include <stdio.h>
#include <unistd.h>

extern char** environ;

int main()
{
        int i = 0;
        for(char** env = environ; env[i]; env++)
        {
                printf("env[%d]->%s\n", i, *env);
                i++;
        }
        return 0;
}
```
![[Pasted image 20251112214059.png]]

**方法二**
>main函数的参数中直接获取

上面提及命令行参数时, main函数有两个参数是不完整的, main函数一共有三个默认的参数
```bash
int main(int argc, char* argv[], char* envp[])
```
* envp(environment pointer)
![[Pasted image 20251112214909.png]]
![[Pasted image 20251112214853.png]]
**方法三**
> getenv方法获取指定key的环境变量的值

```c
char* getenv(const char* name)
```

![[Pasted image 20251112215459.png]]

>结合以上三种方式, 不难得到以下结论
>1. 命令行参数和环境变量本质上都是二级指针, 都指向一个**表**,命令含参数的表是通过用户输入的命令行参数组织的(读取参数之后, 由bash传递给子进程), 而环境变量的表是将bash加载到内存中时从配置文件中读取的,, 这两个表都是父进程bash创建的全局变量, bash下面的子进程可以自动继承

**export 的理解**
>export会在 environ表中新增一个key-val, 但是export本身不是一个子进程吗(属于bash), 子进程创建的变量为什么会被父进程读取并存储呢?
>关键在于 类似于 export echo 这种命令 属于 **内建命令**
大部分的命令都是通过bash创建子进程去执行的(去PATH中搜索需要执行命令的可执行程序路径), 但是少数的命令是直接由bash执行的, 内建命令就是bash直接在自己的进程中执行的命令  

**验证**

![[Pasted image 20251112220601.png]]

![[Pasted image 20251119104234.png]]

* 还有另一种验证方式, man export是无法查看的,因为man是linux系统级的手册,查不到shell的builtin命令, 只能通过help查看
* echo 创建的变量是**本地变量**,只能通过bash查看,子进程无法访问

> 总结 : bash在被加载到内存中时,会**维护两张表**
> 1. 命令行参数表  bash作为父进程会读取命令行参数并存储到**char* argv[]**之中**
> 2. 环境变量表  通过char** environ存储, 在bash进程加载时,通过读取磁盘中的配置文件进行存储(不是动态的, 是提前存储在配置文件中的)

# 进程地址空间
## 代码现象
![[Pasted image 20251119110217.png]]
![[Pasted image 20251119110053.png]]
* 打印的地址相同, 但是变量的值却不同 -- 打印的地址不是实际的物理内存地址
* 打印的本质上是**虚拟地址**

![[Pasted image 20251119111649.png]]
1. 没修改数据之前, 由于子进程继承的是父进程的数据, 值相同, 虚拟地址也相同(共享数据)
2. 如果要修改数据,需要执行**写时拷贝**,即在物理内存中对需要修改的数据重新拷贝一份  为什么?因为进程之间具有独立性
3. 通过**页表**这种数据结构,来建立虚拟地址和实际物理地址之间的映射关系,方便定位到物理内存的实际位置


## 1.什么是地址空间
> 地址空间又叫做进程地址空间,是内存中的一片区域,每一个进程都有自己的进程地址空间
> 进程是通过task_struct进行管理的, 对于进程地址空间也可以使用结构体进行管理,如何管理 : 描述 + 组织

### 地址空间的描述

![[Pasted image 20251119112233.png]]
首先, 进程地址空间内部被划分多个区域, 这些区域之间是连续的,由此可以推断出
* 进程地址空间这个结构体内部有很多属性和**start,end**相关, 通过这两个属性来动态的划分区域
* 其次,进程地址空间的描述是通过结构体进行描述的,在Linux中我们使用**mm_struct**来表示进程地址空间
![[Pasted image 20251119130959.png]]

## 为什么要有地址空间
#### 1.将无序变为有序
如果没有地址空间, 进程所需要 的空间是直接从内存中分配的,而内存空间本质上是一个大仓库, 多个进程对这个大仓库的资源反复申请,销毁,会导致内存碎片化,不连续
而进程地址空间严格规定了一种顺序,是一段**从0开始到高地址的连续空间**,对于数据的访问也是连续的

有序体现在以下几个方面
**1.统一的虚拟地址模型, 内存布局有序整洁**

```
高地址
---------------------
|     栈（向下增长） |
---------------------
|     共享库        |
---------------------
|     堆（向上增长） |
---------------------
|    已初始化数据段 |
---------------------
|    未初始化数据段 |
---------------------
|       代码段      |
---------------------
低地址
```
**2.物理无序--逻辑有序**
内存碎片是无可避免的,但是地址空间可以对内存碎片重新整理,让物理上不连续的地址变为**逻辑有序**

#### 2.进程管理模块和内存管理模块的解耦
新增中间人, 解耦;进程的变动不会影响实际物理内存
还可以让所有的进程**以一个统一的视角看待内存**

#### 3.拦截非法请求
如果直接让进程访问物理内存,可能会存在非法访问(数组越界,访问到其他进程的数据)

## 进一步理解页表和写时拷贝
**页表**
实际上, 页表并不是简单的 虚拟地址 -- 物理地址的映射, 还有很多标记位来辅助操作系统
比如是否在内存中 -- OS判定此时进程挂起/被交换到磁盘中
还可以标记数据的权限(rwx权限) -- 为什么c语言中字符串常量无法被修改 -- 只有r权限(尝试通过虚拟地址定位到物理地址进行修改时,发现只有r权限, 也就无法执行修改操作)

**写时拷贝**
>子进程会继承父进程的数据, 虚拟地址相同, 如果不修改数据, 虚拟地址映射的实际物理地址也是相同的
>如果子进程尝试对**共享数据**进行修改,操作系统会直接在内存上重新开辟一片空间, 并将要修改的数据进行拷贝,让子进程在这个空间上进行修改,从而不影响父进程, 这就叫做**写时拷贝**
>一旦写入, 就会触发**写时拷贝**, 是一种按需申请内存资源的策略

好处:
1. 最大化利用内存空间 : 很多时候子进程对父进程数据的访问仅仅只是**读**,如果全部重新拷贝一份, 会浪费内存空间


![[Pasted image 20251119134129.png]]

**底层理解(从cpu角度)**
![[Pasted image 20251119180126.png]]
地址转换步骤 :
1. CPU的MMU读取当前进程的CR3
2. 根据页表的结构去读取
3. 根据提供的虚拟地址,找到实际的物理地址
OS识别到错误  
1.是不是在物理内存 不在  缺页中断
2.是不是写时拷贝  是  进行写时拷贝  引用计数
3.如果都不是 抛出异常

## 再次认识虚拟地址
我们写的代码在被编译为可执行程序之后, 以二进制的形式进行存储, 你会发现存储的是一个一个地址(函数, 变量等等), 也就是说, 程序在磁盘中已经有地址了, 这个地址是编译器提供的**虚拟地址**

OS再加载程序时, 会将虚拟地址存储到页表之中, 然后和实际的物理地址建立映射关系


再次深入理解  fokr()函数返回两个数据
![[Pasted image 20251119185757.png]]

>操作系统创建一个进程 = 创建pcb(task_struct) + 地址空间(mm_struct) + 页表

# Linux调度算法
我们这里讲的调度算法是**分时调度算法**, 最大的特点就是公平
![[Pasted image 20251119190825.png]]
![[Pasted image 20251119191323.png]]






























