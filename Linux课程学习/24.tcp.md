# 一.全连接队列和半连接队列
在Linux中,tcp的链接,内核会创建两个队列:
1. 半连接队列: 收到客户端SYN, 但是未发送SYN+ACK, 处于`SYN-RECEIVED`状态
2. 全连接队列: 已经完成三次握手的客户端socket, 处于`ESTABLISHED`状态, 需要被accept拿走

当tcpserver启动listen去监听连接, 就会创建这两个队列
```c
int listen(int sockfd, int backlog);
```
* backlog = 半连接 + 全连接队列的最大数量

accept的本质是从`全连接队列队首节点`, 然后创建新的socket和fd用于和客户端通信
```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

![[Pasted image 20260208132053.png]]
`半连接队列和全连接队列本质就是生产者消费者模型!!!`
`半连接队列存在的意义`
1. 防止SYN-FLOOD: 客户端只发送SYN, 不发送ack -->内核资源一直被占用, 消耗服务器资源
2. 应对高并发: 同一时间大量客户端请求建立连接, 服务器来不及创建连接 --> 缓冲区等待

`全连接队列存在的意义`
1. 上层应用accept太慢, 又不能全部丢弃 -->在全连接队列存储
2. 主要是针对应用处理速度慢的问题

