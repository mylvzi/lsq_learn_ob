>HEAD可以指向任意分支, 被HEAD指向的分支才是当前工作的分支

```c
git branch # 查看有哪些本地分支
git branch dev # 创建一个dev分支
git checkout dev # 切换分支dev
git merge dev # 在master分支上合并dev分支
git checkout -d dev # 删除dev分支
git checkout -b dev # 创建并切换到dev分支
```


![[Pasted image 20251218162815.png]]
* 新创建的dev分支是在**当前提交**的时间线上,新建立的一个分支, 此分支也指向当前提交

![[Pasted image 20251218175913.png]]

## 分支冲突
两个分支同时commit到暂存区, 执行合并操作, git不知道保存哪一个分支的提交
![[Pasted image 20251218180632.png]]

**有冲突修改之后还需要在进行一次提交操作!!!**
查看日志
![[Pasted image 20251218180805.png]]
## 合并模式
![[Pasted image 20251218181326.png]]
目前采用**recursive**模式进行合并, 是一种智能的合并方式,. 会帮助我们自动生成一次commit
![[Pasted image 20251218181407.png]]

![[Pasted image 20251218182006.png]]

```c
git merge --no-ff dev1 # 一定生成一个合并提交(好习惯)
```

## 分支策略
![[Pasted image 20251218165338.png]]
* master分支是主分支, 必须是最稳定的分支, 一般是线上环境的分支
* dev分支  不稳定, 存在bug的
* 测试完成之后,才可以将dev分支合并到master分支
* 所以说,分支策略保证了线上环境的安全性


## bug分支
>我新建了dev1分支, 需要开发一个新功能,但此时master分支上出现了bug,需要去解决
>首先不可以直接在dev1分支上处理这个bug, 这是不规范的, dev1只用来新增功能, 需要新创建一个分支去专门修bug


![[Pasted image 20251218183022.png]]

* 切回dev1分支,执行 `git stash`, 暂存工作区内容
![[Pasted image 20251218183040.png]]
![[Pasted image 20251218183121.png]]

* 创建fix_bug分支, 修复bug, 并和master分支合并
![[Pasted image 20251218183231.png]]

此时,就会有一个问题, 就是dev分支的创建是没有fix_bug之前,也就是dev分支目前落后于master分支, 如果直接和master分支合并, 就会包冲突, 一个解决方案是**直接在dev1分支上合并master分支, 保证没有冲突, 再回到master分支合并dev1**

```c
git stash pop // 恢复dev1分支之前的工作区
git merge master

# 解决冲突
# 解决完毕
git add .
git commit -m "md demo1"
git merge master

# 切回master
git checkout master
git merge dev1

git branch -d dev1
```

![[Pasted image 20251218171317.png]]

## 强制删除分支

![[Pasted image 20251218171413.png]]


![[Pasted image 20251218184019.png]]
* 已经在dev1上修改并commit, 但是还没有merge

![[Pasted image 20251218184100.png]]
* 不让删除, 因为git认为创建的branch都是有意义的, 不能随便删除
* 合并之后,完成任务,才可以自由删除
* 没有merge, 但是新开发的功能就是不要了, 直接删除git branch -D dev
![[Pasted image 20251218184209.png]]