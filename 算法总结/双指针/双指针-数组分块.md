> 数组按某种规则划分成左右两块，然后用双指针原地重排

# 一. 经典分两块
[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/)
```java
class Solution {
    public void moveZeroes(int[] nums) {
        // 0-l  l - r  r-(n-1)
        int n = nums.length, l = -1, r = 0;
        while(r < n){
            int tmp = nums[r];
            if(tmp != 0)
                swap(nums, ++l, r++);
            else
                r++;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;
    }
}
```
[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 数据分块  和283类似  283是val = 0
        int l = -1, cur = 0;
        while(cur < nums.length) {
            if(nums[cur] == val)
                ++cur;
            else 
                swap(nums, ++l, cur++);
        }
        return l + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;
    }
}
```
[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        // 数组分块  非重复元素  重复元素
        // [已去重区，未处理区]
        int n = nums.length, l = 0, r = 1;
        while(r < n) {
            if(nums[r] != nums[l])
                swap(nums, ++l, r++);
            else
                ++r;
        }

        return l + 1;
    }

    private void swap(int[] nums, int l, int r) {
        int tmp = nums[l]; nums[l] = nums[r]; nums[r] = tmp;
    }
}
```
[905. 按奇偶排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-array-by-parity/)
```java
class Solution {
    public int[] sortArrayByParity(int[] nums) {
        int n = nums.length, l = -1, r = 0;
        while(r < n) {
            if(nums[r] % 2 == 0)
                swap(nums, ++l, r++);
            else
                ++r;
        }

        return nums;
    }

    private void swap(int[] nums, int l, int r) {
        int tmp = nums[l]; nums[l] = nums[r]; nums[r] = tmp;
    }
}
```

# 二.三分块（进阶版）
[75. 颜色分类 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-colors/description/)
```java
class Solution {
    public void sortColors(int[] nums) {
    	// [ 0区 | 1区 | 2区 ]
        int l = -1, cur = 0, n = nums.length, r = n;
        while(cur < r) {
            int tmp = nums[cur];
            if(tmp == 0) swap(nums, ++l, cur++);
            else if(tmp == 1) ++cur;
            else swap(nums, --r, cur); 
        }
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;
    }
}
```
[88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/description/)
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 看似merger，实则数组分块
        // [空位 | 有效数据]
        // 倒着填
        int i = m - 1, j = n - 1, cur = m + n - 1;
        while(i >= 0 && j >= 0) {
            if(nums1[i] > nums2[j]) nums1[cur--] = nums1[i--];
            else nums1[cur--] = nums2[j--];
        }

        while(i >= 0) nums1[cur--] = nums1[i--];
        while(j >= 0) nums1[cur--] = nums2[j--];
    }
}
```
[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // [绝对值递减区 | 绝对值递增区]
        // 合并两个有序数组
        int n = nums.length, l = 0, r = n - 1, cur = n - 1;
        int[] tmp = new int[n];

        while(l <= r) {
            if(Math.abs(nums[l]) > Math.abs(nums[r])) {
                tmp[cur] = nums[l] * nums[l];
                cur--; l++;
            } else{
                tmp[cur] = nums[r] * nums[r];
                cur--; r--;
            }
        }

        return tmp;
    }
}
```

# 三. 快排（优化版）
快排的核心在于 `选取基准值，并进行数组分块`，它本质上是一个 `递归的数组分块`
* 【0-l】：< pivot
* 【l+1，cur-1】：= pivot
* 【cur，r-1】：未处理
* 【r，end】：> pivot
链接： [912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/description/)
代码
```java
class Solution {
    public int[] sortArray(int[] nums) {
        // 快排：递归数组分块
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    private void quickSort(int[] nums, int start, int end) {
        if(start >= end) return;

        int pivot = nums[start + new Random().nextInt(end - start + 1)];
        int l = start - 1, r = end + 1, cur = start;
        while(cur < r) {
            if(nums[cur] > pivot) swap(nums, --r, cur);
            else if(nums[cur] == pivot) ++cur;
            else swap(nums, ++l, cur++);
        }

        quickSort(nums, start, l);
        quickSort(nums, r, end);
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;
    }
}
```
同样的思路可用于：[215. 数组中的第K个最大元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 快速选择算法实现O(N)的时间复杂度
        return quickSelect(nums, 0, nums.length - 1, k);
    }

    private int quickSelect(int[] nums, int start, int end, int k) {
        if(start >= end) return nums[start];

        int pivot = nums[start + new Random().nextInt(end - start + 1)];
        int l = start - 1, r = end + 1, cur = start;
        while(cur < r) {
            int tmp = nums[cur];
            if(tmp < pivot) swap(nums, ++l, cur++);
            else if(tmp > pivot) swap(nums, --r, cur);
            else ++cur;
        }

        // [start, l] [l + 1, r - 1] [r, end]
        int a = l - start + 1, b = (r - 1) - (l + 1) + 1, c = end - r + 1;
        if(c >= k) return quickSelect(nums, r, end, k);
        else if(b + c >= k) return pivot;
        else return quickSelect(nums, start, l, k - b - c);
    }

    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;
    }
}
```